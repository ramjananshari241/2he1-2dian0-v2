const er = {
  less: "less than a minute read",
  default: "min read"
}, tr = {
  less: "moins d'une minute de lecture",
  default: "min de lecture"
}, ur = {
  less: "menos de un minuto leyendo",
  default: "min de lectura"
}, Dt = {
  less: "å°äºä¸€åˆ†é’Ÿ",
  default: "åˆ†é’Ÿ"
}, rr = {
  less: "1åˆ†æœªæº€ã®èª­ã¿å–ã‚Š",
  default: "æœ€å°èª­ã¿å–ã‚Š"
}, ir = {
  less: "weniger als eine Minute Lesezeit",
  default: "Min. Lesezeit"
}, nr = {
  less: "menos de um minuto de leitura",
  default: "minutos de leitura"
}, ar = {
  less: "bir dakikadan az okuma sÃ¼resi",
  default: "dakika okuma sÃ¼resi"
}, sr = {
  less: "timp de citire mai puÈ›in de un minut",
  default: "min. timp de lecturÄƒ"
}, or = {
  less: "à¦à¦• à¦®à¦¿à¦¨à¦¿à¦Ÿà§‡à¦° à¦•à¦® à¦¸à¦®à¦¯à¦¼à§‡ à¦ªà¦¡à¦¼à§à¦¨",
  default: "à¦¸à¦°à§à¦¬à¦¨à¦¿à¦®à§à¦¨ à¦¸à¦®à¦¯à¦¼à§‡ à¦ªà¦¡à¦¼à§à¦¨"
}, cr = {
  less: "menej ako minÃºta ÄÃ­tania",
  default: "min ÄÃ­tania"
}, lr = {
  less: "mÃ©nÄ› neÅ¾ minuta ÄtenÃ­",
  default: "min ÄtenÃ­"
}, fr = {
  less: "å°‘æ–¼ä¸€åˆ†é˜",
  default: "åˆ†é˜"
}, dr = {
  less: "Ğ¼ĞµĞ½ĞµĞµ Ğ¼Ğ¸Ğ½ÑƒÑ‚Ñ‹ Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ",
  default: "Ğ¼Ğ¸Ğ½ Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ"
}, hr = {
  less: "chÆ°a Ä‘áº§y má»™t phÃºt Ä‘á»c",
  default: "phÃºt Ä‘á»c"
}, pr = {
  less: "meno di un minuto di lettura",
  default: "min di lettura"
}, br = {
  less: "kurang dari satu menit baca",
  default: "menit baca"
}, mr = {
  en: er,
  fr: tr,
  es: ur,
  "zh-cn": Dt,
  "zh-tw": fr,
  cn: Dt,
  ja: rr,
  de: ir,
  "pt-br": nr,
  tr: ar,
  ro: sr,
  bn: or,
  sk: cr,
  cs: lr,
  ru: dr,
  vi: hr,
  it: pr,
  id: br
}, Kr = [
  "en",
  "fr",
  "es",
  "cn",
  // keeping for compatibility
  "zh-cn",
  "zh-tw",
  "ja",
  "de",
  "pt-br",
  "tr",
  "ro",
  "bn",
  "sk",
  "cs",
  "ru",
  "vi",
  "it",
  "id"
];
function gr(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function yr(r) {
  if (Object.prototype.hasOwnProperty.call(r, "__esModule")) return r;
  var E = r.default;
  if (typeof E == "function") {
    var w = function l() {
      return this instanceof l ? Reflect.construct(E, arguments, this.constructor) : E.apply(this, arguments);
    };
    w.prototype = E.prototype;
  } else w = {};
  return Object.defineProperty(w, "__esModule", { value: !0 }), Object.keys(r).forEach(function(l) {
    var h = Object.getOwnPropertyDescriptor(r, l);
    Object.defineProperty(w, l, h.get ? h : {
      enumerable: !0,
      get: function() {
        return r[l];
      }
    });
  }), w;
}
var Z = {}, Y = {}, He = {}, K = {}, Te = {}, Pt;
function vr() {
  return Pt || (Pt = 1, Object.defineProperty(Te, "__esModule", { value: !0 }), Te.default = new Uint16Array(
    // prettier-ignore
    'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map(function(r) {
      return r.charCodeAt(0);
    })
  )), Te;
}
var Ae = {}, Lt;
function xr() {
  return Lt || (Lt = 1, Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.default = new Uint16Array(
    // prettier-ignore
    "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map(function(r) {
      return r.charCodeAt(0);
    })
  )), Ae;
}
var Fe = {}, Rt;
function Mt() {
  return Rt || (Rt = 1, function(r) {
    var E;
    Object.defineProperty(r, "__esModule", { value: !0 }), r.replaceCodePoint = r.fromCodePoint = void 0;
    var w = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    r.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (E = String.fromCodePoint) !== null && E !== void 0 ? E : function(g) {
      var c = "";
      return g > 65535 && (g -= 65536, c += String.fromCharCode(g >>> 10 & 1023 | 55296), g = 56320 | g & 1023), c += String.fromCharCode(g), c;
    };
    function l(g) {
      var c;
      return g >= 55296 && g <= 57343 || g > 1114111 ? 65533 : (c = w.get(g)) !== null && c !== void 0 ? c : g;
    }
    r.replaceCodePoint = l;
    function h(g) {
      return (0, r.fromCodePoint)(l(g));
    }
    r.default = h;
  }(Fe)), Fe;
}
var kt;
function De() {
  return kt || (kt = 1, function(r) {
    var E = K && K.__createBinding || (Object.create ? function(T, O, D, L) {
      L === void 0 && (L = D);
      var N = Object.getOwnPropertyDescriptor(O, D);
      (!N || ("get" in N ? !O.__esModule : N.writable || N.configurable)) && (N = { enumerable: !0, get: function() {
        return O[D];
      } }), Object.defineProperty(T, L, N);
    } : function(T, O, D, L) {
      L === void 0 && (L = D), T[L] = O[D];
    }), w = K && K.__setModuleDefault || (Object.create ? function(T, O) {
      Object.defineProperty(T, "default", { enumerable: !0, value: O });
    } : function(T, O) {
      T.default = O;
    }), l = K && K.__importStar || function(T) {
      if (T && T.__esModule) return T;
      var O = {};
      if (T != null) for (var D in T) D !== "default" && Object.prototype.hasOwnProperty.call(T, D) && E(O, T, D);
      return w(O, T), O;
    }, h = K && K.__importDefault || function(T) {
      return T && T.__esModule ? T : { default: T };
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), r.decodeXML = r.decodeHTMLStrict = r.decodeHTMLAttribute = r.decodeHTML = r.determineBranch = r.EntityDecoder = r.DecodingMode = r.BinTrieFlags = r.fromCodePoint = r.replaceCodePoint = r.decodeCodePoint = r.xmlDecodeTree = r.htmlDecodeTree = void 0;
    var g = h(/* @__PURE__ */ vr());
    r.htmlDecodeTree = g.default;
    var c = h(/* @__PURE__ */ xr());
    r.xmlDecodeTree = c.default;
    var f = l(/* @__PURE__ */ Mt());
    r.decodeCodePoint = f.default;
    var m = /* @__PURE__ */ Mt();
    Object.defineProperty(r, "replaceCodePoint", { enumerable: !0, get: function() {
      return m.replaceCodePoint;
    } }), Object.defineProperty(r, "fromCodePoint", { enumerable: !0, get: function() {
      return m.fromCodePoint;
    } });
    var i;
    (function(T) {
      T[T.NUM = 35] = "NUM", T[T.SEMI = 59] = "SEMI", T[T.EQUALS = 61] = "EQUALS", T[T.ZERO = 48] = "ZERO", T[T.NINE = 57] = "NINE", T[T.LOWER_A = 97] = "LOWER_A", T[T.LOWER_F = 102] = "LOWER_F", T[T.LOWER_X = 120] = "LOWER_X", T[T.LOWER_Z = 122] = "LOWER_Z", T[T.UPPER_A = 65] = "UPPER_A", T[T.UPPER_F = 70] = "UPPER_F", T[T.UPPER_Z = 90] = "UPPER_Z";
    })(i || (i = {}));
    var u = 32, o;
    (function(T) {
      T[T.VALUE_LENGTH = 49152] = "VALUE_LENGTH", T[T.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", T[T.JUMP_TABLE = 127] = "JUMP_TABLE";
    })(o = r.BinTrieFlags || (r.BinTrieFlags = {}));
    function e(T) {
      return T >= i.ZERO && T <= i.NINE;
    }
    function t(T) {
      return T >= i.UPPER_A && T <= i.UPPER_F || T >= i.LOWER_A && T <= i.LOWER_F;
    }
    function s(T) {
      return T >= i.UPPER_A && T <= i.UPPER_Z || T >= i.LOWER_A && T <= i.LOWER_Z || e(T);
    }
    function d(T) {
      return T === i.EQUALS || s(T);
    }
    var b;
    (function(T) {
      T[T.EntityStart = 0] = "EntityStart", T[T.NumericStart = 1] = "NumericStart", T[T.NumericDecimal = 2] = "NumericDecimal", T[T.NumericHex = 3] = "NumericHex", T[T.NamedEntity = 4] = "NamedEntity";
    })(b || (b = {}));
    var n;
    (function(T) {
      T[T.Legacy = 0] = "Legacy", T[T.Strict = 1] = "Strict", T[T.Attribute = 2] = "Attribute";
    })(n = r.DecodingMode || (r.DecodingMode = {}));
    var p = (
      /** @class */
      function() {
        function T(O, D, L) {
          this.decodeTree = O, this.emitCodePoint = D, this.errors = L, this.state = b.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = n.Strict;
        }
        return T.prototype.startEntity = function(O) {
          this.decodeMode = O, this.state = b.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
        }, T.prototype.write = function(O, D) {
          switch (this.state) {
            case b.EntityStart:
              return O.charCodeAt(D) === i.NUM ? (this.state = b.NumericStart, this.consumed += 1, this.stateNumericStart(O, D + 1)) : (this.state = b.NamedEntity, this.stateNamedEntity(O, D));
            case b.NumericStart:
              return this.stateNumericStart(O, D);
            case b.NumericDecimal:
              return this.stateNumericDecimal(O, D);
            case b.NumericHex:
              return this.stateNumericHex(O, D);
            case b.NamedEntity:
              return this.stateNamedEntity(O, D);
          }
        }, T.prototype.stateNumericStart = function(O, D) {
          return D >= O.length ? -1 : (O.charCodeAt(D) | u) === i.LOWER_X ? (this.state = b.NumericHex, this.consumed += 1, this.stateNumericHex(O, D + 1)) : (this.state = b.NumericDecimal, this.stateNumericDecimal(O, D));
        }, T.prototype.addToNumericResult = function(O, D, L, N) {
          if (D !== L) {
            var j = L - D;
            this.result = this.result * Math.pow(N, j) + parseInt(O.substr(D, j), N), this.consumed += j;
          }
        }, T.prototype.stateNumericHex = function(O, D) {
          for (var L = D; D < O.length; ) {
            var N = O.charCodeAt(D);
            if (e(N) || t(N))
              D += 1;
            else
              return this.addToNumericResult(O, L, D, 16), this.emitNumericEntity(N, 3);
          }
          return this.addToNumericResult(O, L, D, 16), -1;
        }, T.prototype.stateNumericDecimal = function(O, D) {
          for (var L = D; D < O.length; ) {
            var N = O.charCodeAt(D);
            if (e(N))
              D += 1;
            else
              return this.addToNumericResult(O, L, D, 10), this.emitNumericEntity(N, 2);
          }
          return this.addToNumericResult(O, L, D, 10), -1;
        }, T.prototype.emitNumericEntity = function(O, D) {
          var L;
          if (this.consumed <= D)
            return (L = this.errors) === null || L === void 0 || L.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          if (O === i.SEMI)
            this.consumed += 1;
          else if (this.decodeMode === n.Strict)
            return 0;
          return this.emitCodePoint((0, f.replaceCodePoint)(this.result), this.consumed), this.errors && (O !== i.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
        }, T.prototype.stateNamedEntity = function(O, D) {
          for (var L = this.decodeTree, N = L[this.treeIndex], j = (N & o.VALUE_LENGTH) >> 14; D < O.length; D++, this.excess++) {
            var B = O.charCodeAt(D);
            if (this.treeIndex = x(L, N, this.treeIndex + Math.max(1, j), B), this.treeIndex < 0)
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === n.Attribute && // We shouldn't have consumed any characters after the entity,
              (j === 0 || // And there should be no invalid characters.
              d(B)) ? 0 : this.emitNotTerminatedNamedEntity();
            if (N = L[this.treeIndex], j = (N & o.VALUE_LENGTH) >> 14, j !== 0) {
              if (B === i.SEMI)
                return this.emitNamedEntityData(this.treeIndex, j, this.consumed + this.excess);
              this.decodeMode !== n.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
            }
          }
          return -1;
        }, T.prototype.emitNotTerminatedNamedEntity = function() {
          var O, D = this, L = D.result, N = D.decodeTree, j = (N[L] & o.VALUE_LENGTH) >> 14;
          return this.emitNamedEntityData(L, j, this.consumed), (O = this.errors) === null || O === void 0 || O.missingSemicolonAfterCharacterReference(), this.consumed;
        }, T.prototype.emitNamedEntityData = function(O, D, L) {
          var N = this.decodeTree;
          return this.emitCodePoint(D === 1 ? N[O] & ~o.VALUE_LENGTH : N[O + 1], L), D === 3 && this.emitCodePoint(N[O + 2], L), L;
        }, T.prototype.end = function() {
          var O;
          switch (this.state) {
            case b.NamedEntity:
              return this.result !== 0 && (this.decodeMode !== n.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            // Otherwise, emit a numeric entity if we have one.
            case b.NumericDecimal:
              return this.emitNumericEntity(0, 2);
            case b.NumericHex:
              return this.emitNumericEntity(0, 3);
            case b.NumericStart:
              return (O = this.errors) === null || O === void 0 || O.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
            case b.EntityStart:
              return 0;
          }
        }, T;
      }()
    );
    r.EntityDecoder = p;
    function y(T) {
      var O = "", D = new p(T, function(L) {
        return O += (0, f.fromCodePoint)(L);
      });
      return function(N, j) {
        for (var B = 0, F = 0; (F = N.indexOf("&", F)) >= 0; ) {
          O += N.slice(B, F), D.startEntity(j);
          var G = D.write(
            N,
            // Skip the "&"
            F + 1
          );
          if (G < 0) {
            B = F + D.end();
            break;
          }
          B = F + G, F = G === 0 ? B + 1 : B;
        }
        var W = O + N.slice(B);
        return O = "", W;
      };
    }
    function x(T, O, D, L) {
      var N = (O & o.BRANCH_LENGTH) >> 7, j = O & o.JUMP_TABLE;
      if (N === 0)
        return j !== 0 && L === j ? D : -1;
      if (j) {
        var B = L - j;
        return B < 0 || B >= N ? -1 : T[D + B] - 1;
      }
      for (var F = D, G = F + N - 1; F <= G; ) {
        var W = F + G >>> 1, ue = T[W];
        if (ue < L)
          F = W + 1;
        else if (ue > L)
          G = W - 1;
        else
          return T[W + N];
      }
      return -1;
    }
    r.determineBranch = x;
    var a = y(g.default), v = y(c.default);
    function S(T, O) {
      return O === void 0 && (O = n.Legacy), a(T, O);
    }
    r.decodeHTML = S;
    function A(T) {
      return a(T, n.Attribute);
    }
    r.decodeHTMLAttribute = A;
    function I(T) {
      return a(T, n.Strict);
    }
    r.decodeHTMLStrict = I;
    function q(T) {
      return v(T, n.Strict);
    }
    r.decodeXML = q;
  }(K)), K;
}
var jt;
function Hu() {
  return jt || (jt = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.QuoteType = void 0;
    var E = /* @__PURE__ */ De(), w;
    (function(e) {
      e[e.Tab = 9] = "Tab", e[e.NewLine = 10] = "NewLine", e[e.FormFeed = 12] = "FormFeed", e[e.CarriageReturn = 13] = "CarriageReturn", e[e.Space = 32] = "Space", e[e.ExclamationMark = 33] = "ExclamationMark", e[e.Number = 35] = "Number", e[e.Amp = 38] = "Amp", e[e.SingleQuote = 39] = "SingleQuote", e[e.DoubleQuote = 34] = "DoubleQuote", e[e.Dash = 45] = "Dash", e[e.Slash = 47] = "Slash", e[e.Zero = 48] = "Zero", e[e.Nine = 57] = "Nine", e[e.Semi = 59] = "Semi", e[e.Lt = 60] = "Lt", e[e.Eq = 61] = "Eq", e[e.Gt = 62] = "Gt", e[e.Questionmark = 63] = "Questionmark", e[e.UpperA = 65] = "UpperA", e[e.LowerA = 97] = "LowerA", e[e.UpperF = 70] = "UpperF", e[e.LowerF = 102] = "LowerF", e[e.UpperZ = 90] = "UpperZ", e[e.LowerZ = 122] = "LowerZ", e[e.LowerX = 120] = "LowerX", e[e.OpeningSquareBracket = 91] = "OpeningSquareBracket";
    })(w || (w = {}));
    var l;
    (function(e) {
      e[e.Text = 1] = "Text", e[e.BeforeTagName = 2] = "BeforeTagName", e[e.InTagName = 3] = "InTagName", e[e.InSelfClosingTag = 4] = "InSelfClosingTag", e[e.BeforeClosingTagName = 5] = "BeforeClosingTagName", e[e.InClosingTagName = 6] = "InClosingTagName", e[e.AfterClosingTagName = 7] = "AfterClosingTagName", e[e.BeforeAttributeName = 8] = "BeforeAttributeName", e[e.InAttributeName = 9] = "InAttributeName", e[e.AfterAttributeName = 10] = "AfterAttributeName", e[e.BeforeAttributeValue = 11] = "BeforeAttributeValue", e[e.InAttributeValueDq = 12] = "InAttributeValueDq", e[e.InAttributeValueSq = 13] = "InAttributeValueSq", e[e.InAttributeValueNq = 14] = "InAttributeValueNq", e[e.BeforeDeclaration = 15] = "BeforeDeclaration", e[e.InDeclaration = 16] = "InDeclaration", e[e.InProcessingInstruction = 17] = "InProcessingInstruction", e[e.BeforeComment = 18] = "BeforeComment", e[e.CDATASequence = 19] = "CDATASequence", e[e.InSpecialComment = 20] = "InSpecialComment", e[e.InCommentLike = 21] = "InCommentLike", e[e.BeforeSpecialS = 22] = "BeforeSpecialS", e[e.SpecialStartSequence = 23] = "SpecialStartSequence", e[e.InSpecialTag = 24] = "InSpecialTag", e[e.BeforeEntity = 25] = "BeforeEntity", e[e.BeforeNumericEntity = 26] = "BeforeNumericEntity", e[e.InNamedEntity = 27] = "InNamedEntity", e[e.InNumericEntity = 28] = "InNumericEntity", e[e.InHexEntity = 29] = "InHexEntity";
    })(l || (l = {}));
    function h(e) {
      return e === w.Space || e === w.NewLine || e === w.Tab || e === w.FormFeed || e === w.CarriageReturn;
    }
    function g(e) {
      return e === w.Slash || e === w.Gt || h(e);
    }
    function c(e) {
      return e >= w.Zero && e <= w.Nine;
    }
    function f(e) {
      return e >= w.LowerA && e <= w.LowerZ || e >= w.UpperA && e <= w.UpperZ;
    }
    function m(e) {
      return e >= w.UpperA && e <= w.UpperF || e >= w.LowerA && e <= w.LowerF;
    }
    var i;
    (function(e) {
      e[e.NoValue = 0] = "NoValue", e[e.Unquoted = 1] = "Unquoted", e[e.Single = 2] = "Single", e[e.Double = 3] = "Double";
    })(i = r.QuoteType || (r.QuoteType = {}));
    var u = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      CdataEnd: new Uint8Array([93, 93, 62]),
      CommentEnd: new Uint8Array([45, 45, 62]),
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
      // `</title`
    }, o = (
      /** @class */
      function() {
        function e(t, s) {
          var d = t.xmlMode, b = d === void 0 ? !1 : d, n = t.decodeEntities, p = n === void 0 ? !0 : n;
          this.cbs = s, this.state = l.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = l.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.trieIndex = 0, this.trieCurrent = 0, this.entityResult = 0, this.entityExcess = 0, this.xmlMode = b, this.decodeEntities = p, this.entityTrie = b ? E.xmlDecodeTree : E.htmlDecodeTree;
        }
        return e.prototype.reset = function() {
          this.state = l.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = l.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
        }, e.prototype.write = function(t) {
          this.offset += this.buffer.length, this.buffer = t, this.parse();
        }, e.prototype.end = function() {
          this.running && this.finish();
        }, e.prototype.pause = function() {
          this.running = !1;
        }, e.prototype.resume = function() {
          this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
        }, e.prototype.getIndex = function() {
          return this.index;
        }, e.prototype.getSectionStart = function() {
          return this.sectionStart;
        }, e.prototype.stateText = function(t) {
          t === w.Lt || !this.decodeEntities && this.fastForwardTo(w.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = l.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && t === w.Amp && (this.state = l.BeforeEntity);
        }, e.prototype.stateSpecialStartSequence = function(t) {
          var s = this.sequenceIndex === this.currentSequence.length, d = s ? (
            // If we are at the end of the sequence, make sure the tag name has ended
            g(t)
          ) : (
            // Otherwise, do a case-insensitive comparison
            (t | 32) === this.currentSequence[this.sequenceIndex]
          );
          if (!d)
            this.isSpecial = !1;
          else if (!s) {
            this.sequenceIndex++;
            return;
          }
          this.sequenceIndex = 0, this.state = l.InTagName, this.stateInTagName(t);
        }, e.prototype.stateInSpecialTag = function(t) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (t === w.Gt || h(t)) {
              var s = this.index - this.currentSequence.length;
              if (this.sectionStart < s) {
                var d = this.index;
                this.index = s, this.cbs.ontext(this.sectionStart, s), this.index = d;
              }
              this.isSpecial = !1, this.sectionStart = s + 2, this.stateInClosingTagName(t);
              return;
            }
            this.sequenceIndex = 0;
          }
          (t | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === u.TitleEnd ? this.decodeEntities && t === w.Amp && (this.state = l.BeforeEntity) : this.fastForwardTo(w.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(t === w.Lt);
        }, e.prototype.stateCDATASequence = function(t) {
          t === u.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === u.Cdata.length && (this.state = l.InCommentLike, this.currentSequence = u.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = l.InDeclaration, this.stateInDeclaration(t));
        }, e.prototype.fastForwardTo = function(t) {
          for (; ++this.index < this.buffer.length + this.offset; )
            if (this.buffer.charCodeAt(this.index - this.offset) === t)
              return !0;
          return this.index = this.buffer.length + this.offset - 1, !1;
        }, e.prototype.stateInCommentLike = function(t) {
          t === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === u.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = l.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : t !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
        }, e.prototype.isTagStartChar = function(t) {
          return this.xmlMode ? !g(t) : f(t);
        }, e.prototype.startSpecial = function(t, s) {
          this.isSpecial = !0, this.currentSequence = t, this.sequenceIndex = s, this.state = l.SpecialStartSequence;
        }, e.prototype.stateBeforeTagName = function(t) {
          if (t === w.ExclamationMark)
            this.state = l.BeforeDeclaration, this.sectionStart = this.index + 1;
          else if (t === w.Questionmark)
            this.state = l.InProcessingInstruction, this.sectionStart = this.index + 1;
          else if (this.isTagStartChar(t)) {
            var s = t | 32;
            this.sectionStart = this.index, !this.xmlMode && s === u.TitleEnd[2] ? this.startSpecial(u.TitleEnd, 3) : this.state = !this.xmlMode && s === u.ScriptEnd[2] ? l.BeforeSpecialS : l.InTagName;
          } else t === w.Slash ? this.state = l.BeforeClosingTagName : (this.state = l.Text, this.stateText(t));
        }, e.prototype.stateInTagName = function(t) {
          g(t) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = l.BeforeAttributeName, this.stateBeforeAttributeName(t));
        }, e.prototype.stateBeforeClosingTagName = function(t) {
          h(t) || (t === w.Gt ? this.state = l.Text : (this.state = this.isTagStartChar(t) ? l.InClosingTagName : l.InSpecialComment, this.sectionStart = this.index));
        }, e.prototype.stateInClosingTagName = function(t) {
          (t === w.Gt || h(t)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = l.AfterClosingTagName, this.stateAfterClosingTagName(t));
        }, e.prototype.stateAfterClosingTagName = function(t) {
          (t === w.Gt || this.fastForwardTo(w.Gt)) && (this.state = l.Text, this.baseState = l.Text, this.sectionStart = this.index + 1);
        }, e.prototype.stateBeforeAttributeName = function(t) {
          t === w.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = l.InSpecialTag, this.sequenceIndex = 0) : this.state = l.Text, this.baseState = this.state, this.sectionStart = this.index + 1) : t === w.Slash ? this.state = l.InSelfClosingTag : h(t) || (this.state = l.InAttributeName, this.sectionStart = this.index);
        }, e.prototype.stateInSelfClosingTag = function(t) {
          t === w.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = l.Text, this.baseState = l.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : h(t) || (this.state = l.BeforeAttributeName, this.stateBeforeAttributeName(t));
        }, e.prototype.stateInAttributeName = function(t) {
          (t === w.Eq || g(t)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = -1, this.state = l.AfterAttributeName, this.stateAfterAttributeName(t));
        }, e.prototype.stateAfterAttributeName = function(t) {
          t === w.Eq ? this.state = l.BeforeAttributeValue : t === w.Slash || t === w.Gt ? (this.cbs.onattribend(i.NoValue, this.index), this.state = l.BeforeAttributeName, this.stateBeforeAttributeName(t)) : h(t) || (this.cbs.onattribend(i.NoValue, this.index), this.state = l.InAttributeName, this.sectionStart = this.index);
        }, e.prototype.stateBeforeAttributeValue = function(t) {
          t === w.DoubleQuote ? (this.state = l.InAttributeValueDq, this.sectionStart = this.index + 1) : t === w.SingleQuote ? (this.state = l.InAttributeValueSq, this.sectionStart = this.index + 1) : h(t) || (this.sectionStart = this.index, this.state = l.InAttributeValueNq, this.stateInAttributeValueNoQuotes(t));
        }, e.prototype.handleInAttributeValue = function(t, s) {
          t === s || !this.decodeEntities && this.fastForwardTo(s) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(s === w.DoubleQuote ? i.Double : i.Single, this.index), this.state = l.BeforeAttributeName) : this.decodeEntities && t === w.Amp && (this.baseState = this.state, this.state = l.BeforeEntity);
        }, e.prototype.stateInAttributeValueDoubleQuotes = function(t) {
          this.handleInAttributeValue(t, w.DoubleQuote);
        }, e.prototype.stateInAttributeValueSingleQuotes = function(t) {
          this.handleInAttributeValue(t, w.SingleQuote);
        }, e.prototype.stateInAttributeValueNoQuotes = function(t) {
          h(t) || t === w.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(i.Unquoted, this.index), this.state = l.BeforeAttributeName, this.stateBeforeAttributeName(t)) : this.decodeEntities && t === w.Amp && (this.baseState = this.state, this.state = l.BeforeEntity);
        }, e.prototype.stateBeforeDeclaration = function(t) {
          t === w.OpeningSquareBracket ? (this.state = l.CDATASequence, this.sequenceIndex = 0) : this.state = t === w.Dash ? l.BeforeComment : l.InDeclaration;
        }, e.prototype.stateInDeclaration = function(t) {
          (t === w.Gt || this.fastForwardTo(w.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = l.Text, this.sectionStart = this.index + 1);
        }, e.prototype.stateInProcessingInstruction = function(t) {
          (t === w.Gt || this.fastForwardTo(w.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = l.Text, this.sectionStart = this.index + 1);
        }, e.prototype.stateBeforeComment = function(t) {
          t === w.Dash ? (this.state = l.InCommentLike, this.currentSequence = u.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = l.InDeclaration;
        }, e.prototype.stateInSpecialComment = function(t) {
          (t === w.Gt || this.fastForwardTo(w.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = l.Text, this.sectionStart = this.index + 1);
        }, e.prototype.stateBeforeSpecialS = function(t) {
          var s = t | 32;
          s === u.ScriptEnd[3] ? this.startSpecial(u.ScriptEnd, 4) : s === u.StyleEnd[3] ? this.startSpecial(u.StyleEnd, 4) : (this.state = l.InTagName, this.stateInTagName(t));
        }, e.prototype.stateBeforeEntity = function(t) {
          this.entityExcess = 1, this.entityResult = 0, t === w.Number ? this.state = l.BeforeNumericEntity : t === w.Amp || (this.trieIndex = 0, this.trieCurrent = this.entityTrie[0], this.state = l.InNamedEntity, this.stateInNamedEntity(t));
        }, e.prototype.stateInNamedEntity = function(t) {
          if (this.entityExcess += 1, this.trieIndex = (0, E.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, t), this.trieIndex < 0) {
            this.emitNamedEntity(), this.index--;
            return;
          }
          this.trieCurrent = this.entityTrie[this.trieIndex];
          var s = this.trieCurrent & E.BinTrieFlags.VALUE_LENGTH;
          if (s) {
            var d = (s >> 14) - 1;
            if (!this.allowLegacyEntity() && t !== w.Semi)
              this.trieIndex += d;
            else {
              var b = this.index - this.entityExcess + 1;
              b > this.sectionStart && this.emitPartial(this.sectionStart, b), this.entityResult = this.trieIndex, this.trieIndex += d, this.entityExcess = 0, this.sectionStart = this.index + 1, d === 0 && this.emitNamedEntity();
            }
          }
        }, e.prototype.emitNamedEntity = function() {
          if (this.state = this.baseState, this.entityResult !== 0) {
            var t = (this.entityTrie[this.entityResult] & E.BinTrieFlags.VALUE_LENGTH) >> 14;
            switch (t) {
              case 1: {
                this.emitCodePoint(this.entityTrie[this.entityResult] & ~E.BinTrieFlags.VALUE_LENGTH);
                break;
              }
              case 2: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                break;
              }
              case 3:
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]), this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
          }
        }, e.prototype.stateBeforeNumericEntity = function(t) {
          (t | 32) === w.LowerX ? (this.entityExcess++, this.state = l.InHexEntity) : (this.state = l.InNumericEntity, this.stateInNumericEntity(t));
        }, e.prototype.emitNumericEntity = function(t) {
          var s = this.index - this.entityExcess - 1, d = s + 2 + +(this.state === l.InHexEntity);
          d !== this.index && (s > this.sectionStart && this.emitPartial(this.sectionStart, s), this.sectionStart = this.index + Number(t), this.emitCodePoint((0, E.replaceCodePoint)(this.entityResult))), this.state = this.baseState;
        }, e.prototype.stateInNumericEntity = function(t) {
          t === w.Semi ? this.emitNumericEntity(!0) : c(t) ? (this.entityResult = this.entityResult * 10 + (t - w.Zero), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
        }, e.prototype.stateInHexEntity = function(t) {
          t === w.Semi ? this.emitNumericEntity(!0) : c(t) ? (this.entityResult = this.entityResult * 16 + (t - w.Zero), this.entityExcess++) : m(t) ? (this.entityResult = this.entityResult * 16 + ((t | 32) - w.LowerA + 10), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
        }, e.prototype.allowLegacyEntity = function() {
          return !this.xmlMode && (this.baseState === l.Text || this.baseState === l.InSpecialTag);
        }, e.prototype.cleanup = function() {
          this.running && this.sectionStart !== this.index && (this.state === l.Text || this.state === l.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === l.InAttributeValueDq || this.state === l.InAttributeValueSq || this.state === l.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
        }, e.prototype.shouldContinue = function() {
          return this.index < this.buffer.length + this.offset && this.running;
        }, e.prototype.parse = function() {
          for (; this.shouldContinue(); ) {
            var t = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
              case l.Text: {
                this.stateText(t);
                break;
              }
              case l.SpecialStartSequence: {
                this.stateSpecialStartSequence(t);
                break;
              }
              case l.InSpecialTag: {
                this.stateInSpecialTag(t);
                break;
              }
              case l.CDATASequence: {
                this.stateCDATASequence(t);
                break;
              }
              case l.InAttributeValueDq: {
                this.stateInAttributeValueDoubleQuotes(t);
                break;
              }
              case l.InAttributeName: {
                this.stateInAttributeName(t);
                break;
              }
              case l.InCommentLike: {
                this.stateInCommentLike(t);
                break;
              }
              case l.InSpecialComment: {
                this.stateInSpecialComment(t);
                break;
              }
              case l.BeforeAttributeName: {
                this.stateBeforeAttributeName(t);
                break;
              }
              case l.InTagName: {
                this.stateInTagName(t);
                break;
              }
              case l.InClosingTagName: {
                this.stateInClosingTagName(t);
                break;
              }
              case l.BeforeTagName: {
                this.stateBeforeTagName(t);
                break;
              }
              case l.AfterAttributeName: {
                this.stateAfterAttributeName(t);
                break;
              }
              case l.InAttributeValueSq: {
                this.stateInAttributeValueSingleQuotes(t);
                break;
              }
              case l.BeforeAttributeValue: {
                this.stateBeforeAttributeValue(t);
                break;
              }
              case l.BeforeClosingTagName: {
                this.stateBeforeClosingTagName(t);
                break;
              }
              case l.AfterClosingTagName: {
                this.stateAfterClosingTagName(t);
                break;
              }
              case l.BeforeSpecialS: {
                this.stateBeforeSpecialS(t);
                break;
              }
              case l.InAttributeValueNq: {
                this.stateInAttributeValueNoQuotes(t);
                break;
              }
              case l.InSelfClosingTag: {
                this.stateInSelfClosingTag(t);
                break;
              }
              case l.InDeclaration: {
                this.stateInDeclaration(t);
                break;
              }
              case l.BeforeDeclaration: {
                this.stateBeforeDeclaration(t);
                break;
              }
              case l.BeforeComment: {
                this.stateBeforeComment(t);
                break;
              }
              case l.InProcessingInstruction: {
                this.stateInProcessingInstruction(t);
                break;
              }
              case l.InNamedEntity: {
                this.stateInNamedEntity(t);
                break;
              }
              case l.BeforeEntity: {
                this.stateBeforeEntity(t);
                break;
              }
              case l.InHexEntity: {
                this.stateInHexEntity(t);
                break;
              }
              case l.InNumericEntity: {
                this.stateInNumericEntity(t);
                break;
              }
              default:
                this.stateBeforeNumericEntity(t);
            }
            this.index++;
          }
          this.cleanup();
        }, e.prototype.finish = function() {
          this.state === l.InNamedEntity && this.emitNamedEntity(), this.sectionStart < this.index && this.handleTrailingData(), this.cbs.onend();
        }, e.prototype.handleTrailingData = function() {
          var t = this.buffer.length + this.offset;
          this.state === l.InCommentLike ? this.currentSequence === u.CdataEnd ? this.cbs.oncdata(this.sectionStart, t, 0) : this.cbs.oncomment(this.sectionStart, t, 0) : this.state === l.InNumericEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === l.InHexEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === l.InTagName || this.state === l.BeforeAttributeName || this.state === l.BeforeAttributeValue || this.state === l.AfterAttributeName || this.state === l.InAttributeName || this.state === l.InAttributeValueSq || this.state === l.InAttributeValueDq || this.state === l.InAttributeValueNq || this.state === l.InClosingTagName || this.cbs.ontext(this.sectionStart, t);
        }, e.prototype.emitPartial = function(t, s) {
          this.baseState !== l.Text && this.baseState !== l.InSpecialTag ? this.cbs.onattribdata(t, s) : this.cbs.ontext(t, s);
        }, e.prototype.emitCodePoint = function(t) {
          this.baseState !== l.Text && this.baseState !== l.InSpecialTag ? this.cbs.onattribentity(t) : this.cbs.ontextentity(t);
        }, e;
      }()
    );
    r.default = o;
  }(He)), He;
}
var Bt;
function Ut() {
  if (Bt) return Y;
  Bt = 1;
  var r = Y && Y.__createBinding || (Object.create ? function(b, n, p, y) {
    y === void 0 && (y = p);
    var x = Object.getOwnPropertyDescriptor(n, p);
    (!x || ("get" in x ? !n.__esModule : x.writable || x.configurable)) && (x = { enumerable: !0, get: function() {
      return n[p];
    } }), Object.defineProperty(b, y, x);
  } : function(b, n, p, y) {
    y === void 0 && (y = p), b[y] = n[p];
  }), E = Y && Y.__setModuleDefault || (Object.create ? function(b, n) {
    Object.defineProperty(b, "default", { enumerable: !0, value: n });
  } : function(b, n) {
    b.default = n;
  }), w = Y && Y.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var n = {};
    if (b != null) for (var p in b) p !== "default" && Object.prototype.hasOwnProperty.call(b, p) && r(n, b, p);
    return E(n, b), n;
  };
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.Parser = void 0;
  var l = w(/* @__PURE__ */ Hu()), h = /* @__PURE__ */ De(), g = /* @__PURE__ */ new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]), c = /* @__PURE__ */ new Set(["p"]), f = /* @__PURE__ */ new Set(["thead", "tbody"]), m = /* @__PURE__ */ new Set(["dd", "dt"]), i = /* @__PURE__ */ new Set(["rt", "rp"]), u = /* @__PURE__ */ new Map([
    ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
    ["th", /* @__PURE__ */ new Set(["th"])],
    ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
    ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
    ["li", /* @__PURE__ */ new Set(["li"])],
    ["p", c],
    ["h1", c],
    ["h2", c],
    ["h3", c],
    ["h4", c],
    ["h5", c],
    ["h6", c],
    ["select", g],
    ["input", g],
    ["output", g],
    ["button", g],
    ["datalist", g],
    ["textarea", g],
    ["option", /* @__PURE__ */ new Set(["option"])],
    ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
    ["dd", m],
    ["dt", m],
    ["address", c],
    ["article", c],
    ["aside", c],
    ["blockquote", c],
    ["details", c],
    ["div", c],
    ["dl", c],
    ["fieldset", c],
    ["figcaption", c],
    ["figure", c],
    ["footer", c],
    ["form", c],
    ["header", c],
    ["hr", c],
    ["main", c],
    ["nav", c],
    ["ol", c],
    ["pre", c],
    ["section", c],
    ["table", c],
    ["ul", c],
    ["rt", i],
    ["rp", i],
    ["tbody", f],
    ["tfoot", f]
  ]), o = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]), e = /* @__PURE__ */ new Set(["math", "svg"]), t = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
  ]), s = /\s|\//, d = (
    /** @class */
    function() {
      function b(n, p) {
        p === void 0 && (p = {});
        var y, x, a, v, S;
        this.options = p, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.foreignContext = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = n ?? {}, this.lowerCaseTagNames = (y = p.lowerCaseTags) !== null && y !== void 0 ? y : !p.xmlMode, this.lowerCaseAttributeNames = (x = p.lowerCaseAttributeNames) !== null && x !== void 0 ? x : !p.xmlMode, this.tokenizer = new ((a = p.Tokenizer) !== null && a !== void 0 ? a : l.default)(this.options, this), (S = (v = this.cbs).onparserinit) === null || S === void 0 || S.call(v, this);
      }
      return b.prototype.ontext = function(n, p) {
        var y, x, a = this.getSlice(n, p);
        this.endIndex = p - 1, (x = (y = this.cbs).ontext) === null || x === void 0 || x.call(y, a), this.startIndex = p;
      }, b.prototype.ontextentity = function(n) {
        var p, y, x = this.tokenizer.getSectionStart();
        this.endIndex = x - 1, (y = (p = this.cbs).ontext) === null || y === void 0 || y.call(p, (0, h.fromCodePoint)(n)), this.startIndex = x;
      }, b.prototype.isVoidElement = function(n) {
        return !this.options.xmlMode && o.has(n);
      }, b.prototype.onopentagname = function(n, p) {
        this.endIndex = p;
        var y = this.getSlice(n, p);
        this.lowerCaseTagNames && (y = y.toLowerCase()), this.emitOpenTag(y);
      }, b.prototype.emitOpenTag = function(n) {
        var p, y, x, a;
        this.openTagStart = this.startIndex, this.tagname = n;
        var v = !this.options.xmlMode && u.get(n);
        if (v)
          for (; this.stack.length > 0 && v.has(this.stack[this.stack.length - 1]); ) {
            var S = this.stack.pop();
            (y = (p = this.cbs).onclosetag) === null || y === void 0 || y.call(p, S, !0);
          }
        this.isVoidElement(n) || (this.stack.push(n), e.has(n) ? this.foreignContext.push(!0) : t.has(n) && this.foreignContext.push(!1)), (a = (x = this.cbs).onopentagname) === null || a === void 0 || a.call(x, n), this.cbs.onopentag && (this.attribs = {});
      }, b.prototype.endOpenTag = function(n) {
        var p, y;
        this.startIndex = this.openTagStart, this.attribs && ((y = (p = this.cbs).onopentag) === null || y === void 0 || y.call(p, this.tagname, this.attribs, n), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
      }, b.prototype.onopentagend = function(n) {
        this.endIndex = n, this.endOpenTag(!1), this.startIndex = n + 1;
      }, b.prototype.onclosetag = function(n, p) {
        var y, x, a, v, S, A;
        this.endIndex = p;
        var I = this.getSlice(n, p);
        if (this.lowerCaseTagNames && (I = I.toLowerCase()), (e.has(I) || t.has(I)) && this.foreignContext.pop(), this.isVoidElement(I))
          !this.options.xmlMode && I === "br" && ((x = (y = this.cbs).onopentagname) === null || x === void 0 || x.call(y, "br"), (v = (a = this.cbs).onopentag) === null || v === void 0 || v.call(a, "br", {}, !0), (A = (S = this.cbs).onclosetag) === null || A === void 0 || A.call(S, "br", !1));
        else {
          var q = this.stack.lastIndexOf(I);
          if (q !== -1)
            if (this.cbs.onclosetag)
              for (var T = this.stack.length - q; T--; )
                this.cbs.onclosetag(this.stack.pop(), T !== 0);
            else
              this.stack.length = q;
          else !this.options.xmlMode && I === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
        }
        this.startIndex = p + 1;
      }, b.prototype.onselfclosingtag = function(n) {
        this.endIndex = n, this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? (this.closeCurrentTag(!1), this.startIndex = n + 1) : this.onopentagend(n);
      }, b.prototype.closeCurrentTag = function(n) {
        var p, y, x = this.tagname;
        this.endOpenTag(n), this.stack[this.stack.length - 1] === x && ((y = (p = this.cbs).onclosetag) === null || y === void 0 || y.call(p, x, !n), this.stack.pop());
      }, b.prototype.onattribname = function(n, p) {
        this.startIndex = n;
        var y = this.getSlice(n, p);
        this.attribname = this.lowerCaseAttributeNames ? y.toLowerCase() : y;
      }, b.prototype.onattribdata = function(n, p) {
        this.attribvalue += this.getSlice(n, p);
      }, b.prototype.onattribentity = function(n) {
        this.attribvalue += (0, h.fromCodePoint)(n);
      }, b.prototype.onattribend = function(n, p) {
        var y, x;
        this.endIndex = p, (x = (y = this.cbs).onattribute) === null || x === void 0 || x.call(y, this.attribname, this.attribvalue, n === l.QuoteType.Double ? '"' : n === l.QuoteType.Single ? "'" : n === l.QuoteType.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
      }, b.prototype.getInstructionName = function(n) {
        var p = n.search(s), y = p < 0 ? n : n.substr(0, p);
        return this.lowerCaseTagNames && (y = y.toLowerCase()), y;
      }, b.prototype.ondeclaration = function(n, p) {
        this.endIndex = p;
        var y = this.getSlice(n, p);
        if (this.cbs.onprocessinginstruction) {
          var x = this.getInstructionName(y);
          this.cbs.onprocessinginstruction("!".concat(x), "!".concat(y));
        }
        this.startIndex = p + 1;
      }, b.prototype.onprocessinginstruction = function(n, p) {
        this.endIndex = p;
        var y = this.getSlice(n, p);
        if (this.cbs.onprocessinginstruction) {
          var x = this.getInstructionName(y);
          this.cbs.onprocessinginstruction("?".concat(x), "?".concat(y));
        }
        this.startIndex = p + 1;
      }, b.prototype.oncomment = function(n, p, y) {
        var x, a, v, S;
        this.endIndex = p, (a = (x = this.cbs).oncomment) === null || a === void 0 || a.call(x, this.getSlice(n, p - y)), (S = (v = this.cbs).oncommentend) === null || S === void 0 || S.call(v), this.startIndex = p + 1;
      }, b.prototype.oncdata = function(n, p, y) {
        var x, a, v, S, A, I, q, T, O, D;
        this.endIndex = p;
        var L = this.getSlice(n, p - y);
        this.options.xmlMode || this.options.recognizeCDATA ? ((a = (x = this.cbs).oncdatastart) === null || a === void 0 || a.call(x), (S = (v = this.cbs).ontext) === null || S === void 0 || S.call(v, L), (I = (A = this.cbs).oncdataend) === null || I === void 0 || I.call(A)) : ((T = (q = this.cbs).oncomment) === null || T === void 0 || T.call(q, "[CDATA[".concat(L, "]]")), (D = (O = this.cbs).oncommentend) === null || D === void 0 || D.call(O)), this.startIndex = p + 1;
      }, b.prototype.onend = function() {
        var n, p;
        if (this.cbs.onclosetag) {
          this.endIndex = this.startIndex;
          for (var y = this.stack.length; y > 0; this.cbs.onclosetag(this.stack[--y], !0))
            ;
        }
        (p = (n = this.cbs).onend) === null || p === void 0 || p.call(n);
      }, b.prototype.reset = function() {
        var n, p, y, x;
        (p = (n = this.cbs).onreset) === null || p === void 0 || p.call(n), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (x = (y = this.cbs).onparserinit) === null || x === void 0 || x.call(y, this), this.buffers.length = 0, this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
      }, b.prototype.parseComplete = function(n) {
        this.reset(), this.end(n);
      }, b.prototype.getSlice = function(n, p) {
        for (; n - this.bufferOffset >= this.buffers[0].length; )
          this.shiftBuffer();
        for (var y = this.buffers[0].slice(n - this.bufferOffset, p - this.bufferOffset); p - this.bufferOffset > this.buffers[0].length; )
          this.shiftBuffer(), y += this.buffers[0].slice(0, p - this.bufferOffset);
        return y;
      }, b.prototype.shiftBuffer = function() {
        this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
      }, b.prototype.write = function(n) {
        var p, y;
        if (this.ended) {
          (y = (p = this.cbs).onerror) === null || y === void 0 || y.call(p, new Error(".write() after done!"));
          return;
        }
        this.buffers.push(n), this.tokenizer.running && (this.tokenizer.write(n), this.writeIndex++);
      }, b.prototype.end = function(n) {
        var p, y;
        if (this.ended) {
          (y = (p = this.cbs).onerror) === null || y === void 0 || y.call(p, new Error(".end() after done!"));
          return;
        }
        n && this.write(n), this.ended = !0, this.tokenizer.end();
      }, b.prototype.pause = function() {
        this.tokenizer.pause();
      }, b.prototype.resume = function() {
        for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
          this.tokenizer.write(this.buffers[this.writeIndex++]);
        this.ended && this.tokenizer.end();
      }, b.prototype.parseChunk = function(n) {
        this.write(n);
      }, b.prototype.done = function(n) {
        this.end(n);
      }, b;
    }()
  );
  return Y.Parser = d, Y;
}
var pe = {}, Ve = {}, Ht;
function xe() {
  return Ht || (Ht = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.Doctype = r.CDATA = r.Tag = r.Style = r.Script = r.Comment = r.Directive = r.Text = r.Root = r.isTag = r.ElementType = void 0;
    var E;
    (function(l) {
      l.Root = "root", l.Text = "text", l.Directive = "directive", l.Comment = "comment", l.Script = "script", l.Style = "style", l.Tag = "tag", l.CDATA = "cdata", l.Doctype = "doctype";
    })(E = r.ElementType || (r.ElementType = {}));
    function w(l) {
      return l.type === E.Tag || l.type === E.Script || l.type === E.Style;
    }
    r.isTag = w, r.Root = E.Root, r.Text = E.Text, r.Directive = E.Directive, r.Comment = E.Comment, r.Script = E.Script, r.Style = E.Style, r.Tag = E.Tag, r.CDATA = E.CDATA, r.Doctype = E.Doctype;
  }(Ve)), Ve;
}
var k = {}, Ft;
function Vt() {
  if (Ft) return k;
  Ft = 1;
  var r = k && k.__extends || /* @__PURE__ */ function() {
    var a = function(v, S) {
      return a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(A, I) {
        A.__proto__ = I;
      } || function(A, I) {
        for (var q in I) Object.prototype.hasOwnProperty.call(I, q) && (A[q] = I[q]);
      }, a(v, S);
    };
    return function(v, S) {
      if (typeof S != "function" && S !== null)
        throw new TypeError("Class extends value " + String(S) + " is not a constructor or null");
      a(v, S);
      function A() {
        this.constructor = v;
      }
      v.prototype = S === null ? Object.create(S) : (A.prototype = S.prototype, new A());
    };
  }(), E = k && k.__assign || function() {
    return E = Object.assign || function(a) {
      for (var v, S = 1, A = arguments.length; S < A; S++) {
        v = arguments[S];
        for (var I in v) Object.prototype.hasOwnProperty.call(v, I) && (a[I] = v[I]);
      }
      return a;
    }, E.apply(this, arguments);
  };
  Object.defineProperty(k, "__esModule", { value: !0 }), k.cloneNode = k.hasChildren = k.isDocument = k.isDirective = k.isComment = k.isText = k.isCDATA = k.isTag = k.Element = k.Document = k.CDATA = k.NodeWithChildren = k.ProcessingInstruction = k.Comment = k.Text = k.DataNode = k.Node = void 0;
  var w = /* @__PURE__ */ xe(), l = (
    /** @class */
    function() {
      function a() {
        this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
      }
      return Object.defineProperty(a.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.parent;
        },
        set: function(v) {
          this.parent = v;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(a.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.prev;
        },
        set: function(v) {
          this.prev = v;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(a.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.next;
        },
        set: function(v) {
          this.next = v;
        },
        enumerable: !1,
        configurable: !0
      }), a.prototype.cloneNode = function(v) {
        return v === void 0 && (v = !1), y(this, v);
      }, a;
    }()
  );
  k.Node = l;
  var h = (
    /** @class */
    function(a) {
      r(v, a);
      function v(S) {
        var A = a.call(this) || this;
        return A.data = S, A;
      }
      return Object.defineProperty(v.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.data;
        },
        set: function(S) {
          this.data = S;
        },
        enumerable: !1,
        configurable: !0
      }), v;
    }(l)
  );
  k.DataNode = h;
  var g = (
    /** @class */
    function(a) {
      r(v, a);
      function v() {
        var S = a !== null && a.apply(this, arguments) || this;
        return S.type = w.ElementType.Text, S;
      }
      return Object.defineProperty(v.prototype, "nodeType", {
        get: function() {
          return 3;
        },
        enumerable: !1,
        configurable: !0
      }), v;
    }(h)
  );
  k.Text = g;
  var c = (
    /** @class */
    function(a) {
      r(v, a);
      function v() {
        var S = a !== null && a.apply(this, arguments) || this;
        return S.type = w.ElementType.Comment, S;
      }
      return Object.defineProperty(v.prototype, "nodeType", {
        get: function() {
          return 8;
        },
        enumerable: !1,
        configurable: !0
      }), v;
    }(h)
  );
  k.Comment = c;
  var f = (
    /** @class */
    function(a) {
      r(v, a);
      function v(S, A) {
        var I = a.call(this, A) || this;
        return I.name = S, I.type = w.ElementType.Directive, I;
      }
      return Object.defineProperty(v.prototype, "nodeType", {
        get: function() {
          return 1;
        },
        enumerable: !1,
        configurable: !0
      }), v;
    }(h)
  );
  k.ProcessingInstruction = f;
  var m = (
    /** @class */
    function(a) {
      r(v, a);
      function v(S) {
        var A = a.call(this) || this;
        return A.children = S, A;
      }
      return Object.defineProperty(v.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */
        get: function() {
          var S;
          return (S = this.children[0]) !== null && S !== void 0 ? S : null;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "lastChild", {
        /** Last child of the node. */
        get: function() {
          return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.children;
        },
        set: function(S) {
          this.children = S;
        },
        enumerable: !1,
        configurable: !0
      }), v;
    }(l)
  );
  k.NodeWithChildren = m;
  var i = (
    /** @class */
    function(a) {
      r(v, a);
      function v() {
        var S = a !== null && a.apply(this, arguments) || this;
        return S.type = w.ElementType.CDATA, S;
      }
      return Object.defineProperty(v.prototype, "nodeType", {
        get: function() {
          return 4;
        },
        enumerable: !1,
        configurable: !0
      }), v;
    }(m)
  );
  k.CDATA = i;
  var u = (
    /** @class */
    function(a) {
      r(v, a);
      function v() {
        var S = a !== null && a.apply(this, arguments) || this;
        return S.type = w.ElementType.Root, S;
      }
      return Object.defineProperty(v.prototype, "nodeType", {
        get: function() {
          return 9;
        },
        enumerable: !1,
        configurable: !0
      }), v;
    }(m)
  );
  k.Document = u;
  var o = (
    /** @class */
    function(a) {
      r(v, a);
      function v(S, A, I, q) {
        I === void 0 && (I = []), q === void 0 && (q = S === "script" ? w.ElementType.Script : S === "style" ? w.ElementType.Style : w.ElementType.Tag);
        var T = a.call(this, I) || this;
        return T.name = S, T.attribs = A, T.type = q, T;
      }
      return Object.defineProperty(v.prototype, "nodeType", {
        get: function() {
          return 1;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.name;
        },
        set: function(S) {
          this.name = S;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "attributes", {
        get: function() {
          var S = this;
          return Object.keys(this.attribs).map(function(A) {
            var I, q;
            return {
              name: A,
              value: S.attribs[A],
              namespace: (I = S["x-attribsNamespace"]) === null || I === void 0 ? void 0 : I[A],
              prefix: (q = S["x-attribsPrefix"]) === null || q === void 0 ? void 0 : q[A]
            };
          });
        },
        enumerable: !1,
        configurable: !0
      }), v;
    }(m)
  );
  k.Element = o;
  function e(a) {
    return (0, w.isTag)(a);
  }
  k.isTag = e;
  function t(a) {
    return a.type === w.ElementType.CDATA;
  }
  k.isCDATA = t;
  function s(a) {
    return a.type === w.ElementType.Text;
  }
  k.isText = s;
  function d(a) {
    return a.type === w.ElementType.Comment;
  }
  k.isComment = d;
  function b(a) {
    return a.type === w.ElementType.Directive;
  }
  k.isDirective = b;
  function n(a) {
    return a.type === w.ElementType.Root;
  }
  k.isDocument = n;
  function p(a) {
    return Object.prototype.hasOwnProperty.call(a, "children");
  }
  k.hasChildren = p;
  function y(a, v) {
    v === void 0 && (v = !1);
    var S;
    if (s(a))
      S = new g(a.data);
    else if (d(a))
      S = new c(a.data);
    else if (e(a)) {
      var A = v ? x(a.children) : [], I = new o(a.name, E({}, a.attribs), A);
      A.forEach(function(D) {
        return D.parent = I;
      }), a.namespace != null && (I.namespace = a.namespace), a["x-attribsNamespace"] && (I["x-attribsNamespace"] = E({}, a["x-attribsNamespace"])), a["x-attribsPrefix"] && (I["x-attribsPrefix"] = E({}, a["x-attribsPrefix"])), S = I;
    } else if (t(a)) {
      var A = v ? x(a.children) : [], q = new i(A);
      A.forEach(function(L) {
        return L.parent = q;
      }), S = q;
    } else if (n(a)) {
      var A = v ? x(a.children) : [], T = new u(A);
      A.forEach(function(L) {
        return L.parent = T;
      }), a["x-mode"] && (T["x-mode"] = a["x-mode"]), S = T;
    } else if (b(a)) {
      var O = new f(a.name, a.data);
      a["x-name"] != null && (O["x-name"] = a["x-name"], O["x-publicId"] = a["x-publicId"], O["x-systemId"] = a["x-systemId"]), S = O;
    } else
      throw new Error("Not implemented yet: ".concat(a.type));
    return S.startIndex = a.startIndex, S.endIndex = a.endIndex, a.sourceCodeLocation != null && (S.sourceCodeLocation = a.sourceCodeLocation), S;
  }
  k.cloneNode = y;
  function x(a) {
    for (var v = a.map(function(A) {
      return y(A, !0);
    }), S = 1; S < v.length; S++)
      v[S].prev = v[S - 1], v[S - 1].next = v[S];
    return v;
  }
  return k;
}
var zt;
function fe() {
  return zt || (zt = 1, function(r) {
    var E = pe && pe.__createBinding || (Object.create ? function(f, m, i, u) {
      u === void 0 && (u = i);
      var o = Object.getOwnPropertyDescriptor(m, i);
      (!o || ("get" in o ? !m.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
        return m[i];
      } }), Object.defineProperty(f, u, o);
    } : function(f, m, i, u) {
      u === void 0 && (u = i), f[u] = m[i];
    }), w = pe && pe.__exportStar || function(f, m) {
      for (var i in f) i !== "default" && !Object.prototype.hasOwnProperty.call(m, i) && E(m, f, i);
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), r.DomHandler = void 0;
    var l = /* @__PURE__ */ xe(), h = /* @__PURE__ */ Vt();
    w(/* @__PURE__ */ Vt(), r);
    var g = {
      withStartIndices: !1,
      withEndIndices: !1,
      xmlMode: !1
    }, c = (
      /** @class */
      function() {
        function f(m, i, u) {
          this.dom = [], this.root = new h.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof i == "function" && (u = i, i = g), typeof m == "object" && (i = m, m = void 0), this.callback = m ?? null, this.options = i ?? g, this.elementCB = u ?? null;
        }
        return f.prototype.onparserinit = function(m) {
          this.parser = m;
        }, f.prototype.onreset = function() {
          this.dom = [], this.root = new h.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
        }, f.prototype.onend = function() {
          this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
        }, f.prototype.onerror = function(m) {
          this.handleCallback(m);
        }, f.prototype.onclosetag = function() {
          this.lastNode = null;
          var m = this.tagStack.pop();
          this.options.withEndIndices && (m.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(m);
        }, f.prototype.onopentag = function(m, i) {
          var u = this.options.xmlMode ? l.ElementType.Tag : void 0, o = new h.Element(m, i, void 0, u);
          this.addNode(o), this.tagStack.push(o);
        }, f.prototype.ontext = function(m) {
          var i = this.lastNode;
          if (i && i.type === l.ElementType.Text)
            i.data += m, this.options.withEndIndices && (i.endIndex = this.parser.endIndex);
          else {
            var u = new h.Text(m);
            this.addNode(u), this.lastNode = u;
          }
        }, f.prototype.oncomment = function(m) {
          if (this.lastNode && this.lastNode.type === l.ElementType.Comment) {
            this.lastNode.data += m;
            return;
          }
          var i = new h.Comment(m);
          this.addNode(i), this.lastNode = i;
        }, f.prototype.oncommentend = function() {
          this.lastNode = null;
        }, f.prototype.oncdatastart = function() {
          var m = new h.Text(""), i = new h.CDATA([m]);
          this.addNode(i), m.parent = i, this.lastNode = m;
        }, f.prototype.oncdataend = function() {
          this.lastNode = null;
        }, f.prototype.onprocessinginstruction = function(m, i) {
          var u = new h.ProcessingInstruction(m, i);
          this.addNode(u);
        }, f.prototype.handleCallback = function(m) {
          if (typeof this.callback == "function")
            this.callback(m, this.dom);
          else if (m)
            throw m;
        }, f.prototype.addNode = function(m) {
          var i = this.tagStack[this.tagStack.length - 1], u = i.children[i.children.length - 1];
          this.options.withStartIndices && (m.startIndex = this.parser.startIndex), this.options.withEndIndices && (m.endIndex = this.parser.endIndex), i.children.push(m), u && (m.prev = u, u.next = m), m.parent = i, this.lastNode = null;
        }, f;
      }()
    );
    r.DomHandler = c, r.default = c;
  }(pe)), pe;
}
var be = {}, ie = {}, Q = {}, ze = {}, ae = {}, Oe = {}, Gt;
function wr() {
  if (Gt) return Oe;
  Gt = 1, Object.defineProperty(Oe, "__esModule", { value: !0 });
  function r(E) {
    for (var w = 1; w < E.length; w++)
      E[w][0] += E[w - 1][0] + 1;
    return E;
  }
  return Oe.default = new Map(/* @__PURE__ */ r([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ r([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ r([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ r([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]])), Oe;
}
var Ge = {}, Wt;
function Et() {
  return Wt || (Wt = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.escapeText = r.escapeAttribute = r.escapeUTF8 = r.escape = r.encodeXML = r.getCodePoint = r.xmlReplacer = void 0, r.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var E = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    r.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? function(h, g) {
      return h.codePointAt(g);
    } : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(h, g) {
        return (h.charCodeAt(g) & 64512) === 55296 ? (h.charCodeAt(g) - 55296) * 1024 + h.charCodeAt(g + 1) - 56320 + 65536 : h.charCodeAt(g);
      }
    );
    function w(h) {
      for (var g = "", c = 0, f; (f = r.xmlReplacer.exec(h)) !== null; ) {
        var m = f.index, i = h.charCodeAt(m), u = E.get(i);
        u !== void 0 ? (g += h.substring(c, m) + u, c = m + 1) : (g += "".concat(h.substring(c, m), "&#x").concat((0, r.getCodePoint)(h, m).toString(16), ";"), c = r.xmlReplacer.lastIndex += +((i & 64512) === 55296));
      }
      return g + h.substr(c);
    }
    r.encodeXML = w, r.escape = w;
    function l(h, g) {
      return function(f) {
        for (var m, i = 0, u = ""; m = h.exec(f); )
          i !== m.index && (u += f.substring(i, m.index)), u += g.get(m[0].charCodeAt(0)), i = m.index + 1;
        return u + f.substring(i);
      };
    }
    r.escapeUTF8 = l(/[&<>'"]/g, E), r.escapeAttribute = l(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ])), r.escapeText = l(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }(Ge)), Ge;
}
var $t;
function Xt() {
  if ($t) return ae;
  $t = 1;
  var r = ae && ae.__importDefault || function(f) {
    return f && f.__esModule ? f : { default: f };
  };
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.encodeNonAsciiHTML = ae.encodeHTML = void 0;
  var E = r(/* @__PURE__ */ wr()), w = /* @__PURE__ */ Et(), l = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
  function h(f) {
    return c(l, f);
  }
  ae.encodeHTML = h;
  function g(f) {
    return c(w.xmlReplacer, f);
  }
  ae.encodeNonAsciiHTML = g;
  function c(f, m) {
    for (var i = "", u = 0, o; (o = f.exec(m)) !== null; ) {
      var e = o.index;
      i += m.substring(u, e);
      var t = m.charCodeAt(e), s = E.default.get(t);
      if (typeof s == "object") {
        if (e + 1 < m.length) {
          var d = m.charCodeAt(e + 1), b = typeof s.n == "number" ? s.n === d ? s.o : void 0 : s.n.get(d);
          if (b !== void 0) {
            i += b, u = f.lastIndex += 1;
            continue;
          }
        }
        s = s.v;
      }
      if (s !== void 0)
        i += s, u = e + 1;
      else {
        var n = (0, w.getCodePoint)(m, e);
        i += "&#x".concat(n.toString(16), ";"), u = f.lastIndex += +(n !== t);
      }
    }
    return i + m.substr(u);
  }
  return ae;
}
var Qt;
function Sr() {
  return Qt || (Qt = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.decodeXMLStrict = r.decodeHTML5Strict = r.decodeHTML4Strict = r.decodeHTML5 = r.decodeHTML4 = r.decodeHTMLAttribute = r.decodeHTMLStrict = r.decodeHTML = r.decodeXML = r.DecodingMode = r.EntityDecoder = r.encodeHTML5 = r.encodeHTML4 = r.encodeNonAsciiHTML = r.encodeHTML = r.escapeText = r.escapeAttribute = r.escapeUTF8 = r.escape = r.encodeXML = r.encode = r.decodeStrict = r.decode = r.EncodingMode = r.EntityLevel = void 0;
    var E = /* @__PURE__ */ De(), w = /* @__PURE__ */ Xt(), l = /* @__PURE__ */ Et(), h;
    (function(e) {
      e[e.XML = 0] = "XML", e[e.HTML = 1] = "HTML";
    })(h = r.EntityLevel || (r.EntityLevel = {}));
    var g;
    (function(e) {
      e[e.UTF8 = 0] = "UTF8", e[e.ASCII = 1] = "ASCII", e[e.Extensive = 2] = "Extensive", e[e.Attribute = 3] = "Attribute", e[e.Text = 4] = "Text";
    })(g = r.EncodingMode || (r.EncodingMode = {}));
    function c(e, t) {
      t === void 0 && (t = h.XML);
      var s = typeof t == "number" ? t : t.level;
      if (s === h.HTML) {
        var d = typeof t == "object" ? t.mode : void 0;
        return (0, E.decodeHTML)(e, d);
      }
      return (0, E.decodeXML)(e);
    }
    r.decode = c;
    function f(e, t) {
      var s;
      t === void 0 && (t = h.XML);
      var d = typeof t == "number" ? { level: t } : t;
      return (s = d.mode) !== null && s !== void 0 || (d.mode = E.DecodingMode.Strict), c(e, d);
    }
    r.decodeStrict = f;
    function m(e, t) {
      t === void 0 && (t = h.XML);
      var s = typeof t == "number" ? { level: t } : t;
      return s.mode === g.UTF8 ? (0, l.escapeUTF8)(e) : s.mode === g.Attribute ? (0, l.escapeAttribute)(e) : s.mode === g.Text ? (0, l.escapeText)(e) : s.level === h.HTML ? s.mode === g.ASCII ? (0, w.encodeNonAsciiHTML)(e) : (0, w.encodeHTML)(e) : (0, l.encodeXML)(e);
    }
    r.encode = m;
    var i = /* @__PURE__ */ Et();
    Object.defineProperty(r, "encodeXML", { enumerable: !0, get: function() {
      return i.encodeXML;
    } }), Object.defineProperty(r, "escape", { enumerable: !0, get: function() {
      return i.escape;
    } }), Object.defineProperty(r, "escapeUTF8", { enumerable: !0, get: function() {
      return i.escapeUTF8;
    } }), Object.defineProperty(r, "escapeAttribute", { enumerable: !0, get: function() {
      return i.escapeAttribute;
    } }), Object.defineProperty(r, "escapeText", { enumerable: !0, get: function() {
      return i.escapeText;
    } });
    var u = /* @__PURE__ */ Xt();
    Object.defineProperty(r, "encodeHTML", { enumerable: !0, get: function() {
      return u.encodeHTML;
    } }), Object.defineProperty(r, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
      return u.encodeNonAsciiHTML;
    } }), Object.defineProperty(r, "encodeHTML4", { enumerable: !0, get: function() {
      return u.encodeHTML;
    } }), Object.defineProperty(r, "encodeHTML5", { enumerable: !0, get: function() {
      return u.encodeHTML;
    } });
    var o = /* @__PURE__ */ De();
    Object.defineProperty(r, "EntityDecoder", { enumerable: !0, get: function() {
      return o.EntityDecoder;
    } }), Object.defineProperty(r, "DecodingMode", { enumerable: !0, get: function() {
      return o.DecodingMode;
    } }), Object.defineProperty(r, "decodeXML", { enumerable: !0, get: function() {
      return o.decodeXML;
    } }), Object.defineProperty(r, "decodeHTML", { enumerable: !0, get: function() {
      return o.decodeHTML;
    } }), Object.defineProperty(r, "decodeHTMLStrict", { enumerable: !0, get: function() {
      return o.decodeHTMLStrict;
    } }), Object.defineProperty(r, "decodeHTMLAttribute", { enumerable: !0, get: function() {
      return o.decodeHTMLAttribute;
    } }), Object.defineProperty(r, "decodeHTML4", { enumerable: !0, get: function() {
      return o.decodeHTML;
    } }), Object.defineProperty(r, "decodeHTML5", { enumerable: !0, get: function() {
      return o.decodeHTML;
    } }), Object.defineProperty(r, "decodeHTML4Strict", { enumerable: !0, get: function() {
      return o.decodeHTMLStrict;
    } }), Object.defineProperty(r, "decodeHTML5Strict", { enumerable: !0, get: function() {
      return o.decodeHTMLStrict;
    } }), Object.defineProperty(r, "decodeXMLStrict", { enumerable: !0, get: function() {
      return o.decodeXML;
    } });
  }(ze)), ze;
}
var me = {}, Jt;
function Er() {
  return Jt || (Jt = 1, Object.defineProperty(me, "__esModule", { value: !0 }), me.attributeNames = me.elementNames = void 0, me.elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map(function(r) {
    return [r.toLowerCase(), r];
  })), me.attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map(function(r) {
    return [r.toLowerCase(), r];
  }))), me;
}
var Zt;
function Tr() {
  if (Zt) return Q;
  Zt = 1;
  var r = Q && Q.__assign || function() {
    return r = Object.assign || function(x) {
      for (var a, v = 1, S = arguments.length; v < S; v++) {
        a = arguments[v];
        for (var A in a) Object.prototype.hasOwnProperty.call(a, A) && (x[A] = a[A]);
      }
      return x;
    }, r.apply(this, arguments);
  }, E = Q && Q.__createBinding || (Object.create ? function(x, a, v, S) {
    S === void 0 && (S = v);
    var A = Object.getOwnPropertyDescriptor(a, v);
    (!A || ("get" in A ? !a.__esModule : A.writable || A.configurable)) && (A = { enumerable: !0, get: function() {
      return a[v];
    } }), Object.defineProperty(x, S, A);
  } : function(x, a, v, S) {
    S === void 0 && (S = v), x[S] = a[v];
  }), w = Q && Q.__setModuleDefault || (Object.create ? function(x, a) {
    Object.defineProperty(x, "default", { enumerable: !0, value: a });
  } : function(x, a) {
    x.default = a;
  }), l = Q && Q.__importStar || function(x) {
    if (x && x.__esModule) return x;
    var a = {};
    if (x != null) for (var v in x) v !== "default" && Object.prototype.hasOwnProperty.call(x, v) && E(a, x, v);
    return w(a, x), a;
  };
  Object.defineProperty(Q, "__esModule", { value: !0 }), Q.render = void 0;
  var h = l(/* @__PURE__ */ xe()), g = /* @__PURE__ */ Sr(), c = /* @__PURE__ */ Er(), f = /* @__PURE__ */ new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  function m(x) {
    return x.replace(/"/g, "&quot;");
  }
  function i(x, a) {
    var v;
    if (x) {
      var S = ((v = a.encodeEntities) !== null && v !== void 0 ? v : a.decodeEntities) === !1 ? m : a.xmlMode || a.encodeEntities !== "utf8" ? g.encodeXML : g.escapeAttribute;
      return Object.keys(x).map(function(A) {
        var I, q, T = (I = x[A]) !== null && I !== void 0 ? I : "";
        return a.xmlMode === "foreign" && (A = (q = c.attributeNames.get(A)) !== null && q !== void 0 ? q : A), !a.emptyAttrs && !a.xmlMode && T === "" ? A : "".concat(A, '="').concat(S(T), '"');
      }).join(" ");
    }
  }
  var u = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  function o(x, a) {
    a === void 0 && (a = {});
    for (var v = ("length" in x) ? x : [x], S = "", A = 0; A < v.length; A++)
      S += e(v[A], a);
    return S;
  }
  Q.render = o, Q.default = o;
  function e(x, a) {
    switch (x.type) {
      case h.Root:
        return o(x.children, a);
      // @ts-expect-error We don't use `Doctype` yet
      case h.Doctype:
      case h.Directive:
        return b(x);
      case h.Comment:
        return y(x);
      case h.CDATA:
        return p(x);
      case h.Script:
      case h.Style:
      case h.Tag:
        return d(x, a);
      case h.Text:
        return n(x, a);
    }
  }
  var t = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]), s = /* @__PURE__ */ new Set(["svg", "math"]);
  function d(x, a) {
    var v;
    a.xmlMode === "foreign" && (x.name = (v = c.elementNames.get(x.name)) !== null && v !== void 0 ? v : x.name, x.parent && t.has(x.parent.name) && (a = r(r({}, a), { xmlMode: !1 }))), !a.xmlMode && s.has(x.name) && (a = r(r({}, a), { xmlMode: "foreign" }));
    var S = "<".concat(x.name), A = i(x.attribs, a);
    return A && (S += " ".concat(A)), x.children.length === 0 && (a.xmlMode ? (
      // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
      a.selfClosingTags !== !1
    ) : (
      // User explicitly asked for self-closing tags, even in HTML mode
      a.selfClosingTags && u.has(x.name)
    )) ? (a.xmlMode || (S += " "), S += "/>") : (S += ">", x.children.length > 0 && (S += o(x.children, a)), (a.xmlMode || !u.has(x.name)) && (S += "</".concat(x.name, ">"))), S;
  }
  function b(x) {
    return "<".concat(x.data, ">");
  }
  function n(x, a) {
    var v, S = x.data || "";
    return ((v = a.encodeEntities) !== null && v !== void 0 ? v : a.decodeEntities) !== !1 && !(!a.xmlMode && x.parent && f.has(x.parent.name)) && (S = a.xmlMode || a.encodeEntities !== "utf8" ? (0, g.encodeXML)(S) : (0, g.escapeText)(S)), S;
  }
  function p(x) {
    return "<![CDATA[".concat(x.children[0].data, "]]>");
  }
  function y(x) {
    return "<!--".concat(x.data, "-->");
  }
  return Q;
}
var Yt;
function Fu() {
  if (Yt) return ie;
  Yt = 1;
  var r = ie && ie.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(ie, "__esModule", { value: !0 }), ie.getOuterHTML = h, ie.getInnerHTML = g, ie.getText = c, ie.textContent = f, ie.innerText = m;
  var E = /* @__PURE__ */ fe(), w = r(/* @__PURE__ */ Tr()), l = /* @__PURE__ */ xe();
  function h(i, u) {
    return (0, w.default)(i, u);
  }
  function g(i, u) {
    return (0, E.hasChildren)(i) ? i.children.map(function(o) {
      return h(o, u);
    }).join("") : "";
  }
  function c(i) {
    return Array.isArray(i) ? i.map(c).join("") : (0, E.isTag)(i) ? i.name === "br" ? `
` : c(i.children) : (0, E.isCDATA)(i) ? c(i.children) : (0, E.isText)(i) ? i.data : "";
  }
  function f(i) {
    return Array.isArray(i) ? i.map(f).join("") : (0, E.hasChildren)(i) && !(0, E.isComment)(i) ? f(i.children) : (0, E.isText)(i) ? i.data : "";
  }
  function m(i) {
    return Array.isArray(i) ? i.map(m).join("") : (0, E.hasChildren)(i) && (i.type === l.ElementType.Tag || (0, E.isCDATA)(i)) ? m(i.children) : (0, E.isText)(i) ? i.data : "";
  }
  return ie;
}
var ee = {}, Kt;
function Ar() {
  if (Kt) return ee;
  Kt = 1, Object.defineProperty(ee, "__esModule", { value: !0 }), ee.getChildren = E, ee.getParent = w, ee.getSiblings = l, ee.getAttributeValue = h, ee.hasAttrib = g, ee.getName = c, ee.nextElementSibling = f, ee.prevElementSibling = m;
  var r = /* @__PURE__ */ fe();
  function E(i) {
    return (0, r.hasChildren)(i) ? i.children : [];
  }
  function w(i) {
    return i.parent || null;
  }
  function l(i) {
    var u, o, e = w(i);
    if (e != null)
      return E(e);
    for (var t = [i], s = i.prev, d = i.next; s != null; )
      t.unshift(s), u = s, s = u.prev;
    for (; d != null; )
      t.push(d), o = d, d = o.next;
    return t;
  }
  function h(i, u) {
    var o;
    return (o = i.attribs) === null || o === void 0 ? void 0 : o[u];
  }
  function g(i, u) {
    return i.attribs != null && Object.prototype.hasOwnProperty.call(i.attribs, u) && i.attribs[u] != null;
  }
  function c(i) {
    return i.name;
  }
  function f(i) {
    for (var u, o = i.next; o !== null && !(0, r.isTag)(o); )
      u = o, o = u.next;
    return o;
  }
  function m(i) {
    for (var u, o = i.prev; o !== null && !(0, r.isTag)(o); )
      u = o, o = u.prev;
    return o;
  }
  return ee;
}
var se = {}, eu;
function Or() {
  if (eu) return se;
  eu = 1, Object.defineProperty(se, "__esModule", { value: !0 }), se.removeElement = r, se.replaceElement = E, se.appendChild = w, se.append = l, se.prependChild = h, se.prepend = g;
  function r(c) {
    if (c.prev && (c.prev.next = c.next), c.next && (c.next.prev = c.prev), c.parent) {
      var f = c.parent.children, m = f.lastIndexOf(c);
      m >= 0 && f.splice(m, 1);
    }
    c.next = null, c.prev = null, c.parent = null;
  }
  function E(c, f) {
    var m = f.prev = c.prev;
    m && (m.next = f);
    var i = f.next = c.next;
    i && (i.prev = f);
    var u = f.parent = c.parent;
    if (u) {
      var o = u.children;
      o[o.lastIndexOf(c)] = f, c.parent = null;
    }
  }
  function w(c, f) {
    if (r(f), f.next = null, f.parent = c, c.children.push(f) > 1) {
      var m = c.children[c.children.length - 2];
      m.next = f, f.prev = m;
    } else
      f.prev = null;
  }
  function l(c, f) {
    r(f);
    var m = c.parent, i = c.next;
    if (f.next = i, f.prev = c, c.next = f, f.parent = m, i) {
      if (i.prev = f, m) {
        var u = m.children;
        u.splice(u.lastIndexOf(i), 0, f);
      }
    } else m && m.children.push(f);
  }
  function h(c, f) {
    if (r(f), f.parent = c, f.prev = null, c.children.unshift(f) !== 1) {
      var m = c.children[1];
      m.prev = f, f.next = m;
    } else
      f.next = null;
  }
  function g(c, f) {
    r(f);
    var m = c.parent;
    if (m) {
      var i = m.children;
      i.splice(i.indexOf(c), 0, f);
    }
    c.prev && (c.prev.next = f), f.parent = m, f.prev = c.prev, f.next = c, c.prev = f;
  }
  return se;
}
var oe = {}, tu;
function Vu() {
  if (tu) return oe;
  tu = 1, Object.defineProperty(oe, "__esModule", { value: !0 }), oe.filter = E, oe.find = w, oe.findOneChild = l, oe.findOne = h, oe.existsOne = g, oe.findAll = c;
  var r = /* @__PURE__ */ fe();
  function E(f, m, i, u) {
    return i === void 0 && (i = !0), u === void 0 && (u = 1 / 0), w(f, Array.isArray(m) ? m : [m], i, u);
  }
  function w(f, m, i, u) {
    for (var o = [], e = [Array.isArray(m) ? m : [m]], t = [0]; ; ) {
      if (t[0] >= e[0].length) {
        if (t.length === 1)
          return o;
        e.shift(), t.shift();
        continue;
      }
      var s = e[0][t[0]++];
      if (f(s) && (o.push(s), --u <= 0))
        return o;
      i && (0, r.hasChildren)(s) && s.children.length > 0 && (t.unshift(0), e.unshift(s.children));
    }
  }
  function l(f, m) {
    return m.find(f);
  }
  function h(f, m, i) {
    i === void 0 && (i = !0);
    for (var u = Array.isArray(m) ? m : [m], o = 0; o < u.length; o++) {
      var e = u[o];
      if ((0, r.isTag)(e) && f(e))
        return e;
      if (i && (0, r.hasChildren)(e) && e.children.length > 0) {
        var t = h(f, e.children, !0);
        if (t)
          return t;
      }
    }
    return null;
  }
  function g(f, m) {
    return (Array.isArray(m) ? m : [m]).some(function(i) {
      return (0, r.isTag)(i) && f(i) || (0, r.hasChildren)(i) && g(f, i.children);
    });
  }
  function c(f, m) {
    for (var i = [], u = [Array.isArray(m) ? m : [m]], o = [0]; ; ) {
      if (o[0] >= u[0].length) {
        if (u.length === 1)
          return i;
        u.shift(), o.shift();
        continue;
      }
      var e = u[0][o[0]++];
      (0, r.isTag)(e) && f(e) && i.push(e), (0, r.hasChildren)(e) && e.children.length > 0 && (o.unshift(0), u.unshift(e.children));
    }
  }
  return oe;
}
var ce = {}, uu;
function zu() {
  if (uu) return ce;
  uu = 1, Object.defineProperty(ce, "__esModule", { value: !0 }), ce.testElement = c, ce.getElements = f, ce.getElementById = m, ce.getElementsByTagName = i, ce.getElementsByClassName = u, ce.getElementsByTagType = o;
  var r = /* @__PURE__ */ fe(), E = /* @__PURE__ */ Vu(), w = {
    tag_name: function(e) {
      return typeof e == "function" ? function(t) {
        return (0, r.isTag)(t) && e(t.name);
      } : e === "*" ? r.isTag : function(t) {
        return (0, r.isTag)(t) && t.name === e;
      };
    },
    tag_type: function(e) {
      return typeof e == "function" ? function(t) {
        return e(t.type);
      } : function(t) {
        return t.type === e;
      };
    },
    tag_contains: function(e) {
      return typeof e == "function" ? function(t) {
        return (0, r.isText)(t) && e(t.data);
      } : function(t) {
        return (0, r.isText)(t) && t.data === e;
      };
    }
  };
  function l(e, t) {
    return typeof t == "function" ? function(s) {
      return (0, r.isTag)(s) && t(s.attribs[e]);
    } : function(s) {
      return (0, r.isTag)(s) && s.attribs[e] === t;
    };
  }
  function h(e, t) {
    return function(s) {
      return e(s) || t(s);
    };
  }
  function g(e) {
    var t = Object.keys(e).map(function(s) {
      var d = e[s];
      return Object.prototype.hasOwnProperty.call(w, s) ? w[s](d) : l(s, d);
    });
    return t.length === 0 ? null : t.reduce(h);
  }
  function c(e, t) {
    var s = g(e);
    return s ? s(t) : !0;
  }
  function f(e, t, s, d) {
    d === void 0 && (d = 1 / 0);
    var b = g(e);
    return b ? (0, E.filter)(b, t, s, d) : [];
  }
  function m(e, t, s) {
    return s === void 0 && (s = !0), Array.isArray(t) || (t = [t]), (0, E.findOne)(l("id", e), t, s);
  }
  function i(e, t, s, d) {
    return s === void 0 && (s = !0), d === void 0 && (d = 1 / 0), (0, E.filter)(w.tag_name(e), t, s, d);
  }
  function u(e, t, s, d) {
    return s === void 0 && (s = !0), d === void 0 && (d = 1 / 0), (0, E.filter)(l("class", e), t, s, d);
  }
  function o(e, t, s, d) {
    return s === void 0 && (s = !0), d === void 0 && (d = 1 / 0), (0, E.filter)(w.tag_type(e), t, s, d);
  }
  return ce;
}
var le = {}, ru;
function Nr() {
  if (ru) return le;
  ru = 1, Object.defineProperty(le, "__esModule", { value: !0 }), le.DocumentPosition = void 0, le.removeSubsets = E, le.compareDocumentPosition = l, le.uniqueSort = h;
  var r = /* @__PURE__ */ fe();
  function E(g) {
    for (var c = g.length; --c >= 0; ) {
      var f = g[c];
      if (c > 0 && g.lastIndexOf(f, c - 1) >= 0) {
        g.splice(c, 1);
        continue;
      }
      for (var m = f.parent; m; m = m.parent)
        if (g.includes(m)) {
          g.splice(c, 1);
          break;
        }
    }
    return g;
  }
  var w;
  (function(g) {
    g[g.DISCONNECTED = 1] = "DISCONNECTED", g[g.PRECEDING = 2] = "PRECEDING", g[g.FOLLOWING = 4] = "FOLLOWING", g[g.CONTAINS = 8] = "CONTAINS", g[g.CONTAINED_BY = 16] = "CONTAINED_BY";
  })(w || (le.DocumentPosition = w = {}));
  function l(g, c) {
    var f = [], m = [];
    if (g === c)
      return 0;
    for (var i = (0, r.hasChildren)(g) ? g : g.parent; i; )
      f.unshift(i), i = i.parent;
    for (i = (0, r.hasChildren)(c) ? c : c.parent; i; )
      m.unshift(i), i = i.parent;
    for (var u = Math.min(f.length, m.length), o = 0; o < u && f[o] === m[o]; )
      o++;
    if (o === 0)
      return w.DISCONNECTED;
    var e = f[o - 1], t = e.children, s = f[o], d = m[o];
    return t.indexOf(s) > t.indexOf(d) ? e === c ? w.FOLLOWING | w.CONTAINED_BY : w.FOLLOWING : e === g ? w.PRECEDING | w.CONTAINS : w.PRECEDING;
  }
  function h(g) {
    return g = g.filter(function(c, f, m) {
      return !m.includes(c, f + 1);
    }), g.sort(function(c, f) {
      var m = l(c, f);
      return m & w.PRECEDING ? -1 : m & w.FOLLOWING ? 1 : 0;
    }), g;
  }
  return le;
}
var Ne = {}, iu;
function _r() {
  if (iu) return Ne;
  iu = 1, Object.defineProperty(Ne, "__esModule", { value: !0 }), Ne.getFeed = w;
  var r = /* @__PURE__ */ Fu(), E = /* @__PURE__ */ zu();
  function w(e) {
    var t = m(o, e);
    return t ? t.name === "feed" ? l(t) : h(t) : null;
  }
  function l(e) {
    var t, s = e.children, d = {
      type: "atom",
      items: (0, E.getElementsByTagName)("entry", s).map(function(p) {
        var y, x = p.children, a = { media: f(x) };
        u(a, "id", "id", x), u(a, "title", "title", x);
        var v = (y = m("link", x)) === null || y === void 0 ? void 0 : y.attribs.href;
        v && (a.link = v);
        var S = i("summary", x) || i("content", x);
        S && (a.description = S);
        var A = i("updated", x);
        return A && (a.pubDate = new Date(A)), a;
      })
    };
    u(d, "id", "id", s), u(d, "title", "title", s);
    var b = (t = m("link", s)) === null || t === void 0 ? void 0 : t.attribs.href;
    b && (d.link = b), u(d, "description", "subtitle", s);
    var n = i("updated", s);
    return n && (d.updated = new Date(n)), u(d, "author", "email", s, !0), d;
  }
  function h(e) {
    var t, s, d = (s = (t = m("channel", e.children)) === null || t === void 0 ? void 0 : t.children) !== null && s !== void 0 ? s : [], b = {
      type: e.name.substr(0, 3),
      id: "",
      items: (0, E.getElementsByTagName)("item", e.children).map(function(p) {
        var y = p.children, x = { media: f(y) };
        u(x, "id", "guid", y), u(x, "title", "title", y), u(x, "link", "link", y), u(x, "description", "description", y);
        var a = i("pubDate", y) || i("dc:date", y);
        return a && (x.pubDate = new Date(a)), x;
      })
    };
    u(b, "title", "title", d), u(b, "link", "link", d), u(b, "description", "description", d);
    var n = i("lastBuildDate", d);
    return n && (b.updated = new Date(n)), u(b, "author", "managingEditor", d, !0), b;
  }
  var g = ["url", "type", "lang"], c = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
  ];
  function f(e) {
    return (0, E.getElementsByTagName)("media:content", e).map(function(t) {
      for (var s = t.attribs, d = {
        medium: s.medium,
        isDefault: !!s.isDefault
      }, b = 0, n = g; b < n.length; b++) {
        var p = n[b];
        s[p] && (d[p] = s[p]);
      }
      for (var y = 0, x = c; y < x.length; y++) {
        var p = x[y];
        s[p] && (d[p] = parseInt(s[p], 10));
      }
      return s.expression && (d.expression = s.expression), d;
    });
  }
  function m(e, t) {
    return (0, E.getElementsByTagName)(e, t, !0, 1)[0];
  }
  function i(e, t, s) {
    return s === void 0 && (s = !1), (0, r.textContent)((0, E.getElementsByTagName)(e, t, s, 1)).trim();
  }
  function u(e, t, s, d, b) {
    b === void 0 && (b = !1);
    var n = i(s, d, b);
    n && (e[t] = n);
  }
  function o(e) {
    return e === "rss" || e === "feed" || e === "rdf:RDF";
  }
  return Ne;
}
var nu;
function We() {
  return nu || (nu = 1, function(r) {
    var E = be && be.__createBinding || (Object.create ? function(h, g, c, f) {
      f === void 0 && (f = c);
      var m = Object.getOwnPropertyDescriptor(g, c);
      (!m || ("get" in m ? !g.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return g[c];
      } }), Object.defineProperty(h, f, m);
    } : function(h, g, c, f) {
      f === void 0 && (f = c), h[f] = g[c];
    }), w = be && be.__exportStar || function(h, g) {
      for (var c in h) c !== "default" && !Object.prototype.hasOwnProperty.call(g, c) && E(g, h, c);
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), r.hasChildren = r.isDocument = r.isComment = r.isText = r.isCDATA = r.isTag = void 0, w(/* @__PURE__ */ Fu(), r), w(/* @__PURE__ */ Ar(), r), w(/* @__PURE__ */ Or(), r), w(/* @__PURE__ */ Vu(), r), w(/* @__PURE__ */ zu(), r), w(/* @__PURE__ */ Nr(), r), w(/* @__PURE__ */ _r(), r);
    var l = /* @__PURE__ */ fe();
    Object.defineProperty(r, "isTag", { enumerable: !0, get: function() {
      return l.isTag;
    } }), Object.defineProperty(r, "isCDATA", { enumerable: !0, get: function() {
      return l.isCDATA;
    } }), Object.defineProperty(r, "isText", { enumerable: !0, get: function() {
      return l.isText;
    } }), Object.defineProperty(r, "isComment", { enumerable: !0, get: function() {
      return l.isComment;
    } }), Object.defineProperty(r, "isDocument", { enumerable: !0, get: function() {
      return l.isDocument;
    } }), Object.defineProperty(r, "hasChildren", { enumerable: !0, get: function() {
      return l.hasChildren;
    } });
  }(be)), be;
}
var au;
function Ir() {
  return au || (au = 1, function(r) {
    var E = Z && Z.__createBinding || (Object.create ? function(n, p, y, x) {
      x === void 0 && (x = y);
      var a = Object.getOwnPropertyDescriptor(p, y);
      (!a || ("get" in a ? !p.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
        return p[y];
      } }), Object.defineProperty(n, x, a);
    } : function(n, p, y, x) {
      x === void 0 && (x = y), n[x] = p[y];
    }), w = Z && Z.__setModuleDefault || (Object.create ? function(n, p) {
      Object.defineProperty(n, "default", { enumerable: !0, value: p });
    } : function(n, p) {
      n.default = p;
    }), l = Z && Z.__importStar || function(n) {
      if (n && n.__esModule) return n;
      var p = {};
      if (n != null) for (var y in n) y !== "default" && Object.prototype.hasOwnProperty.call(n, y) && E(p, n, y);
      return w(p, n), p;
    }, h = Z && Z.__importDefault || function(n) {
      return n && n.__esModule ? n : { default: n };
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), r.DomUtils = r.parseFeed = r.getFeed = r.ElementType = r.Tokenizer = r.createDomStream = r.parseDOM = r.parseDocument = r.DefaultHandler = r.DomHandler = r.Parser = void 0;
    var g = /* @__PURE__ */ Ut(), c = /* @__PURE__ */ Ut();
    Object.defineProperty(r, "Parser", { enumerable: !0, get: function() {
      return c.Parser;
    } });
    var f = /* @__PURE__ */ fe(), m = /* @__PURE__ */ fe();
    Object.defineProperty(r, "DomHandler", { enumerable: !0, get: function() {
      return m.DomHandler;
    } }), Object.defineProperty(r, "DefaultHandler", { enumerable: !0, get: function() {
      return m.DomHandler;
    } });
    function i(n, p) {
      var y = new f.DomHandler(void 0, p);
      return new g.Parser(y, p).end(n), y.root;
    }
    r.parseDocument = i;
    function u(n, p) {
      return i(n, p).children;
    }
    r.parseDOM = u;
    function o(n, p, y) {
      var x = new f.DomHandler(n, p, y);
      return new g.Parser(x, p);
    }
    r.createDomStream = o;
    var e = /* @__PURE__ */ Hu();
    Object.defineProperty(r, "Tokenizer", { enumerable: !0, get: function() {
      return h(e).default;
    } }), r.ElementType = l(/* @__PURE__ */ xe());
    var t = /* @__PURE__ */ We(), s = /* @__PURE__ */ We();
    Object.defineProperty(r, "getFeed", { enumerable: !0, get: function() {
      return s.getFeed;
    } });
    var d = { xmlMode: !0 };
    function b(n, p) {
      return p === void 0 && (p = d), (0, t.getFeed)(u(n, p));
    }
    r.parseFeed = b, r.DomUtils = l(/* @__PURE__ */ We());
  }(Z)), Z;
}
var $e, su;
function qr() {
  return su || (su = 1, $e = (r) => {
    if (typeof r != "string")
      throw new TypeError("Expected a string");
    return r.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }), $e;
}
var _e = {}, ou;
function Cr() {
  if (ou) return _e;
  ou = 1, Object.defineProperty(_e, "__esModule", { value: !0 });
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  function r(w) {
    return Object.prototype.toString.call(w) === "[object Object]";
  }
  function E(w) {
    var l, h;
    return r(w) === !1 ? !1 : (l = w.constructor, l === void 0 ? !0 : (h = l.prototype, !(r(h) === !1 || h.hasOwnProperty("isPrototypeOf") === !1)));
  }
  return _e.isPlainObject = E, _e;
}
var Xe, cu;
function Dr() {
  if (cu) return Xe;
  cu = 1;
  var r = function(p) {
    return E(p) && !w(p);
  };
  function E(n) {
    return !!n && typeof n == "object";
  }
  function w(n) {
    var p = Object.prototype.toString.call(n);
    return p === "[object RegExp]" || p === "[object Date]" || g(n);
  }
  var l = typeof Symbol == "function" && Symbol.for, h = l ? Symbol.for("react.element") : 60103;
  function g(n) {
    return n.$$typeof === h;
  }
  function c(n) {
    return Array.isArray(n) ? [] : {};
  }
  function f(n, p) {
    return p.clone !== !1 && p.isMergeableObject(n) ? d(c(n), n, p) : n;
  }
  function m(n, p, y) {
    return n.concat(p).map(function(x) {
      return f(x, y);
    });
  }
  function i(n, p) {
    if (!p.customMerge)
      return d;
    var y = p.customMerge(n);
    return typeof y == "function" ? y : d;
  }
  function u(n) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(n).filter(function(p) {
      return Object.propertyIsEnumerable.call(n, p);
    }) : [];
  }
  function o(n) {
    return Object.keys(n).concat(u(n));
  }
  function e(n, p) {
    try {
      return p in n;
    } catch {
      return !1;
    }
  }
  function t(n, p) {
    return e(n, p) && !(Object.hasOwnProperty.call(n, p) && Object.propertyIsEnumerable.call(n, p));
  }
  function s(n, p, y) {
    var x = {};
    return y.isMergeableObject(n) && o(n).forEach(function(a) {
      x[a] = f(n[a], y);
    }), o(p).forEach(function(a) {
      t(n, a) || (e(n, a) && y.isMergeableObject(p[a]) ? x[a] = i(a, y)(n[a], p[a], y) : x[a] = f(p[a], y));
    }), x;
  }
  function d(n, p, y) {
    y = y || {}, y.arrayMerge = y.arrayMerge || m, y.isMergeableObject = y.isMergeableObject || r, y.cloneUnlessOtherwiseSpecified = f;
    var x = Array.isArray(p), a = Array.isArray(n), v = x === a;
    return v ? x ? y.arrayMerge(n, p, y) : s(n, p, y) : f(p, y);
  }
  d.all = function(p, y) {
    if (!Array.isArray(p))
      throw new Error("first argument should be an array");
    return p.reduce(function(x, a) {
      return d(x, a, y);
    }, {});
  };
  var b = d;
  return Xe = b, Xe;
}
var Ce = { exports: {} }, Pr = Ce.exports, lu;
function Lr() {
  return lu || (lu = 1, function(r) {
    (function(E, w) {
      r.exports ? r.exports = w() : E.parseSrcset = w();
    })(Pr, function() {
      return function(E) {
        function w(x) {
          return x === " " || // space
          x === "	" || // horizontal tab
          x === `
` || // new line
          x === "\f" || // form feed
          x === "\r";
        }
        function l(x) {
          var a, v = x.exec(E.substring(b));
          if (v)
            return a = v[0], b += a.length, a;
        }
        for (var h = E.length, g = /^[ \t\n\r\u000c]+/, c = /^[, \t\n\r\u000c]+/, f = /^[^ \t\n\r\u000c]+/, m = /[,]+$/, i = /^\d+$/, u = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, o, e, t, s, d, b = 0, n = []; ; ) {
          if (l(c), b >= h)
            return n;
          o = l(f), e = [], o.slice(-1) === "," ? (o = o.replace(m, ""), y()) : p();
        }
        function p() {
          for (l(g), t = "", s = "in descriptor"; ; ) {
            if (d = E.charAt(b), s === "in descriptor")
              if (w(d))
                t && (e.push(t), t = "", s = "after descriptor");
              else if (d === ",") {
                b += 1, t && e.push(t), y();
                return;
              } else if (d === "(")
                t = t + d, s = "in parens";
              else if (d === "") {
                t && e.push(t), y();
                return;
              } else
                t = t + d;
            else if (s === "in parens")
              if (d === ")")
                t = t + d, s = "in descriptor";
              else if (d === "") {
                e.push(t), y();
                return;
              } else
                t = t + d;
            else if (s === "after descriptor" && !w(d))
              if (d === "") {
                y();
                return;
              } else
                s = "in descriptor", b -= 1;
            b += 1;
          }
        }
        function y() {
          var x = !1, a, v, S, A, I = {}, q, T, O, D, L;
          for (A = 0; A < e.length; A++)
            q = e[A], T = q[q.length - 1], O = q.substring(0, q.length - 1), D = parseInt(O, 10), L = parseFloat(O), i.test(O) && T === "w" ? ((a || v) && (x = !0), D === 0 ? x = !0 : a = D) : u.test(O) && T === "x" ? ((a || v || S) && (x = !0), L < 0 ? x = !0 : v = L) : i.test(O) && T === "h" ? ((S || v) && (x = !0), D === 0 ? x = !0 : S = D) : x = !0;
          x ? console && console.log && console.log("Invalid srcset descriptor found in '" + E + "' at '" + q + "'.") : (I.url = o, a && (I.w = a), v && (I.d = v), S && (I.h = S), n.push(I));
        }
      };
    });
  }(Ce)), Ce.exports;
}
var Ie = { exports: {} }, fu;
function Rr() {
  if (fu) return Ie.exports;
  fu = 1;
  var r = String, E = function() {
    return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r, blackBright: r, redBright: r, greenBright: r, yellowBright: r, blueBright: r, magentaBright: r, cyanBright: r, whiteBright: r, bgBlackBright: r, bgRedBright: r, bgGreenBright: r, bgYellowBright: r, bgBlueBright: r, bgMagentaBright: r, bgCyanBright: r, bgWhiteBright: r };
  };
  return Ie.exports = E(), Ie.exports.createColors = E, Ie.exports;
}
const Mr = {}, kr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Mr
}, Symbol.toStringTag, { value: "Module" })), te = /* @__PURE__ */ yr(kr);
var Qe, du;
function Tt() {
  if (du) return Qe;
  du = 1;
  let r = /* @__PURE__ */ Rr(), E = te;
  class w extends Error {
    constructor(h, g, c, f, m, i) {
      super(h), this.name = "CssSyntaxError", this.reason = h, m && (this.file = m), f && (this.source = f), i && (this.plugin = i), typeof g < "u" && typeof c < "u" && (typeof g == "number" ? (this.line = g, this.column = c) : (this.line = g.line, this.column = g.column, this.endLine = c.line, this.endColumn = c.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, w);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(h) {
      if (!this.source) return "";
      let g = this.source;
      h == null && (h = r.isColorSupported);
      let c = (t) => t, f = (t) => t, m = (t) => t;
      if (h) {
        let { bold: t, gray: s, red: d } = r.createColors(!0);
        f = (b) => t(d(b)), c = (b) => s(b), E && (m = (b) => E(b));
      }
      let i = g.split(/\r?\n/), u = Math.max(this.line - 3, 0), o = Math.min(this.line + 2, i.length), e = String(o).length;
      return i.slice(u, o).map((t, s) => {
        let d = u + 1 + s, b = " " + (" " + d).slice(-e) + " | ";
        if (d === this.line) {
          if (t.length > 160) {
            let p = 20, y = Math.max(0, this.column - p), x = Math.max(
              this.column + p,
              this.endColumn + p
            ), a = t.slice(y, x), v = c(b.replace(/\d/g, " ")) + t.slice(0, Math.min(this.column - 1, p - 1)).replace(/[^\t]/g, " ");
            return f(">") + c(b) + m(a) + `
 ` + v + f("^");
          }
          let n = c(b.replace(/\d/g, " ")) + t.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return f(">") + c(b) + m(t) + `
 ` + n + f("^");
        }
        return " " + c(b) + m(t);
      }).join(`
`);
    }
    toString() {
      let h = this.showSourceCode();
      return h && (h = `

` + h + `
`), this.name + ": " + this.message + h;
    }
  }
  return Qe = w, w.default = w, Qe;
}
var Je, hu;
function Gu() {
  if (hu) return Je;
  hu = 1;
  const r = {
    after: `
`,
    beforeClose: `
`,
    beforeComment: `
`,
    beforeDecl: `
`,
    beforeOpen: " ",
    beforeRule: `
`,
    colon: ": ",
    commentLeft: " ",
    commentRight: " ",
    emptyBody: "",
    indent: "    ",
    semicolon: !1
  };
  function E(l) {
    return l[0].toUpperCase() + l.slice(1);
  }
  class w {
    constructor(h) {
      this.builder = h;
    }
    atrule(h, g) {
      let c = "@" + h.name, f = h.params ? this.rawValue(h, "params") : "";
      if (typeof h.raws.afterName < "u" ? c += h.raws.afterName : f && (c += " "), h.nodes)
        this.block(h, c + f);
      else {
        let m = (h.raws.between || "") + (g ? ";" : "");
        this.builder(c + f + m, h);
      }
    }
    beforeAfter(h, g) {
      let c;
      h.type === "decl" ? c = this.raw(h, null, "beforeDecl") : h.type === "comment" ? c = this.raw(h, null, "beforeComment") : g === "before" ? c = this.raw(h, null, "beforeRule") : c = this.raw(h, null, "beforeClose");
      let f = h.parent, m = 0;
      for (; f && f.type !== "root"; )
        m += 1, f = f.parent;
      if (c.includes(`
`)) {
        let i = this.raw(h, null, "indent");
        if (i.length)
          for (let u = 0; u < m; u++) c += i;
      }
      return c;
    }
    block(h, g) {
      let c = this.raw(h, "between", "beforeOpen");
      this.builder(g + c + "{", h, "start");
      let f;
      h.nodes && h.nodes.length ? (this.body(h), f = this.raw(h, "after")) : f = this.raw(h, "after", "emptyBody"), f && this.builder(f), this.builder("}", h, "end");
    }
    body(h) {
      let g = h.nodes.length - 1;
      for (; g > 0 && h.nodes[g].type === "comment"; )
        g -= 1;
      let c = this.raw(h, "semicolon");
      for (let f = 0; f < h.nodes.length; f++) {
        let m = h.nodes[f], i = this.raw(m, "before");
        i && this.builder(i), this.stringify(m, g !== f || c);
      }
    }
    comment(h) {
      let g = this.raw(h, "left", "commentLeft"), c = this.raw(h, "right", "commentRight");
      this.builder("/*" + g + h.text + c + "*/", h);
    }
    decl(h, g) {
      let c = this.raw(h, "between", "colon"), f = h.prop + c + this.rawValue(h, "value");
      h.important && (f += h.raws.important || " !important"), g && (f += ";"), this.builder(f, h);
    }
    document(h) {
      this.body(h);
    }
    raw(h, g, c) {
      let f;
      if (c || (c = g), g && (f = h.raws[g], typeof f < "u"))
        return f;
      let m = h.parent;
      if (c === "before" && (!m || m.type === "root" && m.first === h || m && m.type === "document"))
        return "";
      if (!m) return r[c];
      let i = h.root();
      if (i.rawCache || (i.rawCache = {}), typeof i.rawCache[c] < "u")
        return i.rawCache[c];
      if (c === "before" || c === "after")
        return this.beforeAfter(h, c);
      {
        let u = "raw" + E(c);
        this[u] ? f = this[u](i, h) : i.walk((o) => {
          if (f = o.raws[g], typeof f < "u") return !1;
        });
      }
      return typeof f > "u" && (f = r[c]), i.rawCache[c] = f, f;
    }
    rawBeforeClose(h) {
      let g;
      return h.walk((c) => {
        if (c.nodes && c.nodes.length > 0 && typeof c.raws.after < "u")
          return g = c.raws.after, g.includes(`
`) && (g = g.replace(/[^\n]+$/, "")), !1;
      }), g && (g = g.replace(/\S/g, "")), g;
    }
    rawBeforeComment(h, g) {
      let c;
      return h.walkComments((f) => {
        if (typeof f.raws.before < "u")
          return c = f.raws.before, c.includes(`
`) && (c = c.replace(/[^\n]+$/, "")), !1;
      }), typeof c > "u" ? c = this.raw(g, null, "beforeDecl") : c && (c = c.replace(/\S/g, "")), c;
    }
    rawBeforeDecl(h, g) {
      let c;
      return h.walkDecls((f) => {
        if (typeof f.raws.before < "u")
          return c = f.raws.before, c.includes(`
`) && (c = c.replace(/[^\n]+$/, "")), !1;
      }), typeof c > "u" ? c = this.raw(g, null, "beforeRule") : c && (c = c.replace(/\S/g, "")), c;
    }
    rawBeforeOpen(h) {
      let g;
      return h.walk((c) => {
        if (c.type !== "decl" && (g = c.raws.between, typeof g < "u"))
          return !1;
      }), g;
    }
    rawBeforeRule(h) {
      let g;
      return h.walk((c) => {
        if (c.nodes && (c.parent !== h || h.first !== c) && typeof c.raws.before < "u")
          return g = c.raws.before, g.includes(`
`) && (g = g.replace(/[^\n]+$/, "")), !1;
      }), g && (g = g.replace(/\S/g, "")), g;
    }
    rawColon(h) {
      let g;
      return h.walkDecls((c) => {
        if (typeof c.raws.between < "u")
          return g = c.raws.between.replace(/[^\s:]/g, ""), !1;
      }), g;
    }
    rawEmptyBody(h) {
      let g;
      return h.walk((c) => {
        if (c.nodes && c.nodes.length === 0 && (g = c.raws.after, typeof g < "u"))
          return !1;
      }), g;
    }
    rawIndent(h) {
      if (h.raws.indent) return h.raws.indent;
      let g;
      return h.walk((c) => {
        let f = c.parent;
        if (f && f !== h && f.parent && f.parent === h && typeof c.raws.before < "u") {
          let m = c.raws.before.split(`
`);
          return g = m[m.length - 1], g = g.replace(/\S/g, ""), !1;
        }
      }), g;
    }
    rawSemicolon(h) {
      let g;
      return h.walk((c) => {
        if (c.nodes && c.nodes.length && c.last.type === "decl" && (g = c.raws.semicolon, typeof g < "u"))
          return !1;
      }), g;
    }
    rawValue(h, g) {
      let c = h[g], f = h.raws[g];
      return f && f.value === c ? f.raw : c;
    }
    root(h) {
      this.body(h), h.raws.after && this.builder(h.raws.after);
    }
    rule(h) {
      this.block(h, this.rawValue(h, "selector")), h.raws.ownSemicolon && this.builder(h.raws.ownSemicolon, h, "end");
    }
    stringify(h, g) {
      if (!this[h.type])
        throw new Error(
          "Unknown AST node type " + h.type + ". Maybe you need to change PostCSS stringifier."
        );
      this[h.type](h, g);
    }
  }
  return Je = w, w.default = w, Je;
}
var Ze, pu;
function Pe() {
  if (pu) return Ze;
  pu = 1;
  let r = Gu();
  function E(w, l) {
    new r(l).stringify(w);
  }
  return Ze = E, E.default = E, Ze;
}
var qe = {}, bu;
function At() {
  return bu || (bu = 1, qe.isClean = Symbol("isClean"), qe.my = Symbol("my")), qe;
}
var Ye, mu;
function Le() {
  if (mu) return Ye;
  mu = 1;
  let r = Tt(), E = Gu(), w = Pe(), { isClean: l, my: h } = At();
  function g(m, i) {
    let u = new m.constructor();
    for (let o in m) {
      if (!Object.prototype.hasOwnProperty.call(m, o) || o === "proxyCache") continue;
      let e = m[o], t = typeof e;
      o === "parent" && t === "object" ? i && (u[o] = i) : o === "source" ? u[o] = e : Array.isArray(e) ? u[o] = e.map((s) => g(s, u)) : (t === "object" && e !== null && (e = g(e)), u[o] = e);
    }
    return u;
  }
  function c(m, i) {
    if (i && typeof i.offset < "u")
      return i.offset;
    let u = 1, o = 1, e = 0;
    for (let t = 0; t < m.length; t++) {
      if (o === i.line && u === i.column) {
        e = t;
        break;
      }
      m[t] === `
` ? (u = 1, o += 1) : u += 1;
    }
    return e;
  }
  class f {
    get proxyOf() {
      return this;
    }
    constructor(i = {}) {
      this.raws = {}, this[l] = !1, this[h] = !0;
      for (let u in i)
        if (u === "nodes") {
          this.nodes = [];
          for (let o of i[u])
            typeof o.clone == "function" ? this.append(o.clone()) : this.append(o);
        } else
          this[u] = i[u];
    }
    addToError(i) {
      if (i.postcssNode = this, i.stack && this.source && /\n\s{4}at /.test(i.stack)) {
        let u = this.source;
        i.stack = i.stack.replace(
          /\n\s{4}at /,
          `$&${u.input.from}:${u.start.line}:${u.start.column}$&`
        );
      }
      return i;
    }
    after(i) {
      return this.parent.insertAfter(this, i), this;
    }
    assign(i = {}) {
      for (let u in i)
        this[u] = i[u];
      return this;
    }
    before(i) {
      return this.parent.insertBefore(this, i), this;
    }
    cleanRaws(i) {
      delete this.raws.before, delete this.raws.after, i || delete this.raws.between;
    }
    clone(i = {}) {
      let u = g(this);
      for (let o in i)
        u[o] = i[o];
      return u;
    }
    cloneAfter(i = {}) {
      let u = this.clone(i);
      return this.parent.insertAfter(this, u), u;
    }
    cloneBefore(i = {}) {
      let u = this.clone(i);
      return this.parent.insertBefore(this, u), u;
    }
    error(i, u = {}) {
      if (this.source) {
        let { end: o, start: e } = this.rangeBy(u);
        return this.source.input.error(
          i,
          { column: e.column, line: e.line },
          { column: o.column, line: o.line },
          u
        );
      }
      return new r(i);
    }
    getProxyProcessor() {
      return {
        get(i, u) {
          return u === "proxyOf" ? i : u === "root" ? () => i.root().toProxy() : i[u];
        },
        set(i, u, o) {
          return i[u] === o || (i[u] = o, (u === "prop" || u === "value" || u === "name" || u === "params" || u === "important" || /* c8 ignore next */
          u === "text") && i.markDirty()), !0;
        }
      };
    }
    /* c8 ignore next 3 */
    markClean() {
      this[l] = !0;
    }
    markDirty() {
      if (this[l]) {
        this[l] = !1;
        let i = this;
        for (; i = i.parent; )
          i[l] = !1;
      }
    }
    next() {
      if (!this.parent) return;
      let i = this.parent.index(this);
      return this.parent.nodes[i + 1];
    }
    positionBy(i) {
      let u = this.source.start;
      if (i.index)
        u = this.positionInside(i.index);
      else if (i.word) {
        let o = "document" in this.source.input ? this.source.input.document : this.source.input.css, t = o.slice(
          c(o, this.source.start),
          c(o, this.source.end)
        ).indexOf(i.word);
        t !== -1 && (u = this.positionInside(t));
      }
      return u;
    }
    positionInside(i) {
      let u = this.source.start.column, o = this.source.start.line, e = "document" in this.source.input ? this.source.input.document : this.source.input.css, t = c(e, this.source.start), s = t + i;
      for (let d = t; d < s; d++)
        e[d] === `
` ? (u = 1, o += 1) : u += 1;
      return { column: u, line: o };
    }
    prev() {
      if (!this.parent) return;
      let i = this.parent.index(this);
      return this.parent.nodes[i - 1];
    }
    rangeBy(i) {
      let u = {
        column: this.source.start.column,
        line: this.source.start.line
      }, o = this.source.end ? {
        column: this.source.end.column + 1,
        line: this.source.end.line
      } : {
        column: u.column + 1,
        line: u.line
      };
      if (i.word) {
        let e = "document" in this.source.input ? this.source.input.document : this.source.input.css, s = e.slice(
          c(e, this.source.start),
          c(e, this.source.end)
        ).indexOf(i.word);
        s !== -1 && (u = this.positionInside(s), o = this.positionInside(
          s + i.word.length
        ));
      } else
        i.start ? u = {
          column: i.start.column,
          line: i.start.line
        } : i.index && (u = this.positionInside(i.index)), i.end ? o = {
          column: i.end.column,
          line: i.end.line
        } : typeof i.endIndex == "number" ? o = this.positionInside(i.endIndex) : i.index && (o = this.positionInside(i.index + 1));
      return (o.line < u.line || o.line === u.line && o.column <= u.column) && (o = { column: u.column + 1, line: u.line }), { end: o, start: u };
    }
    raw(i, u) {
      return new E().raw(this, i, u);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...i) {
      if (this.parent) {
        let u = this, o = !1;
        for (let e of i)
          e === this ? o = !0 : o ? (this.parent.insertAfter(u, e), u = e) : this.parent.insertBefore(u, e);
        o || this.remove();
      }
      return this;
    }
    root() {
      let i = this;
      for (; i.parent && i.parent.type !== "document"; )
        i = i.parent;
      return i;
    }
    toJSON(i, u) {
      let o = {}, e = u == null;
      u = u || /* @__PURE__ */ new Map();
      let t = 0;
      for (let s in this) {
        if (!Object.prototype.hasOwnProperty.call(this, s) || s === "parent" || s === "proxyCache") continue;
        let d = this[s];
        if (Array.isArray(d))
          o[s] = d.map((b) => typeof b == "object" && b.toJSON ? b.toJSON(null, u) : b);
        else if (typeof d == "object" && d.toJSON)
          o[s] = d.toJSON(null, u);
        else if (s === "source") {
          let b = u.get(d.input);
          b == null && (b = t, u.set(d.input, t), t++), o[s] = {
            end: d.end,
            inputId: b,
            start: d.start
          };
        } else
          o[s] = d;
      }
      return e && (o.inputs = [...u.keys()].map((s) => s.toJSON())), o;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(i = w) {
      i.stringify && (i = i.stringify);
      let u = "";
      return i(this, (o) => {
        u += o;
      }), u;
    }
    warn(i, u, o) {
      let e = { node: this };
      for (let t in o) e[t] = o[t];
      return i.warn(u, e);
    }
  }
  return Ye = f, f.default = f, Ye;
}
var Ke, gu;
function Re() {
  if (gu) return Ke;
  gu = 1;
  let r = Le();
  class E extends r {
    constructor(l) {
      super(l), this.type = "comment";
    }
  }
  return Ke = E, E.default = E, Ke;
}
var et, yu;
function Me() {
  if (yu) return et;
  yu = 1;
  let r = Le();
  class E extends r {
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
    constructor(l) {
      l && typeof l.value < "u" && typeof l.value != "string" && (l = { ...l, value: String(l.value) }), super(l), this.type = "decl";
    }
  }
  return et = E, E.default = E, et;
}
var tt, vu;
function ge() {
  if (vu) return tt;
  vu = 1;
  let r = Re(), E = Me(), w = Le(), { isClean: l, my: h } = At(), g, c, f, m;
  function i(e) {
    return e.map((t) => (t.nodes && (t.nodes = i(t.nodes)), delete t.source, t));
  }
  function u(e) {
    if (e[l] = !1, e.proxyOf.nodes)
      for (let t of e.proxyOf.nodes)
        u(t);
  }
  class o extends w {
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
    append(...t) {
      for (let s of t) {
        let d = this.normalize(s, this.last);
        for (let b of d) this.proxyOf.nodes.push(b);
      }
      return this.markDirty(), this;
    }
    cleanRaws(t) {
      if (super.cleanRaws(t), this.nodes)
        for (let s of this.nodes) s.cleanRaws(t);
    }
    each(t) {
      if (!this.proxyOf.nodes) return;
      let s = this.getIterator(), d, b;
      for (; this.indexes[s] < this.proxyOf.nodes.length && (d = this.indexes[s], b = t(this.proxyOf.nodes[d], d), b !== !1); )
        this.indexes[s] += 1;
      return delete this.indexes[s], b;
    }
    every(t) {
      return this.nodes.every(t);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let t = this.lastEach;
      return this.indexes[t] = 0, t;
    }
    getProxyProcessor() {
      return {
        get(t, s) {
          return s === "proxyOf" ? t : t[s] ? s === "each" || typeof s == "string" && s.startsWith("walk") ? (...d) => t[s](
            ...d.map((b) => typeof b == "function" ? (n, p) => b(n.toProxy(), p) : b)
          ) : s === "every" || s === "some" ? (d) => t[s](
            (b, ...n) => d(b.toProxy(), ...n)
          ) : s === "root" ? () => t.root().toProxy() : s === "nodes" ? t.nodes.map((d) => d.toProxy()) : s === "first" || s === "last" ? t[s].toProxy() : t[s] : t[s];
        },
        set(t, s, d) {
          return t[s] === d || (t[s] = d, (s === "name" || s === "params" || s === "selector") && t.markDirty()), !0;
        }
      };
    }
    index(t) {
      return typeof t == "number" ? t : (t.proxyOf && (t = t.proxyOf), this.proxyOf.nodes.indexOf(t));
    }
    insertAfter(t, s) {
      let d = this.index(t), b = this.normalize(s, this.proxyOf.nodes[d]).reverse();
      d = this.index(t);
      for (let p of b) this.proxyOf.nodes.splice(d + 1, 0, p);
      let n;
      for (let p in this.indexes)
        n = this.indexes[p], d < n && (this.indexes[p] = n + b.length);
      return this.markDirty(), this;
    }
    insertBefore(t, s) {
      let d = this.index(t), b = d === 0 ? "prepend" : !1, n = this.normalize(
        s,
        this.proxyOf.nodes[d],
        b
      ).reverse();
      d = this.index(t);
      for (let y of n) this.proxyOf.nodes.splice(d, 0, y);
      let p;
      for (let y in this.indexes)
        p = this.indexes[y], d <= p && (this.indexes[y] = p + n.length);
      return this.markDirty(), this;
    }
    normalize(t, s) {
      if (typeof t == "string")
        t = i(c(t).nodes);
      else if (typeof t > "u")
        t = [];
      else if (Array.isArray(t)) {
        t = t.slice(0);
        for (let b of t)
          b.parent && b.parent.removeChild(b, "ignore");
      } else if (t.type === "root" && this.type !== "document") {
        t = t.nodes.slice(0);
        for (let b of t)
          b.parent && b.parent.removeChild(b, "ignore");
      } else if (t.type)
        t = [t];
      else if (t.prop) {
        if (typeof t.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof t.value != "string" && (t.value = String(t.value)), t = [new E(t)];
      } else if (t.selector || t.selectors)
        t = [new m(t)];
      else if (t.name)
        t = [new g(t)];
      else if (t.text)
        t = [new r(t)];
      else
        throw new Error("Unknown node type in node creation");
      return t.map((b) => (b[h] || o.rebuild(b), b = b.proxyOf, b.parent && b.parent.removeChild(b), b[l] && u(b), b.raws || (b.raws = {}), typeof b.raws.before > "u" && s && typeof s.raws.before < "u" && (b.raws.before = s.raws.before.replace(/\S/g, "")), b.parent = this.proxyOf, b));
    }
    prepend(...t) {
      t = t.reverse();
      for (let s of t) {
        let d = this.normalize(s, this.first, "prepend").reverse();
        for (let b of d) this.proxyOf.nodes.unshift(b);
        for (let b in this.indexes)
          this.indexes[b] = this.indexes[b] + d.length;
      }
      return this.markDirty(), this;
    }
    push(t) {
      return t.parent = this, this.proxyOf.nodes.push(t), this;
    }
    removeAll() {
      for (let t of this.proxyOf.nodes) t.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(t) {
      t = this.index(t), this.proxyOf.nodes[t].parent = void 0, this.proxyOf.nodes.splice(t, 1);
      let s;
      for (let d in this.indexes)
        s = this.indexes[d], s >= t && (this.indexes[d] = s - 1);
      return this.markDirty(), this;
    }
    replaceValues(t, s, d) {
      return d || (d = s, s = {}), this.walkDecls((b) => {
        s.props && !s.props.includes(b.prop) || s.fast && !b.value.includes(s.fast) || (b.value = b.value.replace(t, d));
      }), this.markDirty(), this;
    }
    some(t) {
      return this.nodes.some(t);
    }
    walk(t) {
      return this.each((s, d) => {
        let b;
        try {
          b = t(s, d);
        } catch (n) {
          throw s.addToError(n);
        }
        return b !== !1 && s.walk && (b = s.walk(t)), b;
      });
    }
    walkAtRules(t, s) {
      return s ? t instanceof RegExp ? this.walk((d, b) => {
        if (d.type === "atrule" && t.test(d.name))
          return s(d, b);
      }) : this.walk((d, b) => {
        if (d.type === "atrule" && d.name === t)
          return s(d, b);
      }) : (s = t, this.walk((d, b) => {
        if (d.type === "atrule")
          return s(d, b);
      }));
    }
    walkComments(t) {
      return this.walk((s, d) => {
        if (s.type === "comment")
          return t(s, d);
      });
    }
    walkDecls(t, s) {
      return s ? t instanceof RegExp ? this.walk((d, b) => {
        if (d.type === "decl" && t.test(d.prop))
          return s(d, b);
      }) : this.walk((d, b) => {
        if (d.type === "decl" && d.prop === t)
          return s(d, b);
      }) : (s = t, this.walk((d, b) => {
        if (d.type === "decl")
          return s(d, b);
      }));
    }
    walkRules(t, s) {
      return s ? t instanceof RegExp ? this.walk((d, b) => {
        if (d.type === "rule" && t.test(d.selector))
          return s(d, b);
      }) : this.walk((d, b) => {
        if (d.type === "rule" && d.selector === t)
          return s(d, b);
      }) : (s = t, this.walk((d, b) => {
        if (d.type === "rule")
          return s(d, b);
      }));
    }
  }
  return o.registerParse = (e) => {
    c = e;
  }, o.registerRule = (e) => {
    m = e;
  }, o.registerAtRule = (e) => {
    g = e;
  }, o.registerRoot = (e) => {
    f = e;
  }, tt = o, o.default = o, o.rebuild = (e) => {
    e.type === "atrule" ? Object.setPrototypeOf(e, g.prototype) : e.type === "rule" ? Object.setPrototypeOf(e, m.prototype) : e.type === "decl" ? Object.setPrototypeOf(e, E.prototype) : e.type === "comment" ? Object.setPrototypeOf(e, r.prototype) : e.type === "root" && Object.setPrototypeOf(e, f.prototype), e[h] = !0, e.nodes && e.nodes.forEach((t) => {
      o.rebuild(t);
    });
  }, tt;
}
var ut, xu;
function Ot() {
  if (xu) return ut;
  xu = 1;
  let r = ge();
  class E extends r {
    constructor(l) {
      super(l), this.type = "atrule";
    }
    append(...l) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...l);
    }
    prepend(...l) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...l);
    }
  }
  return ut = E, E.default = E, r.registerAtRule(E), ut;
}
var rt, wu;
function Nt() {
  if (wu) return rt;
  wu = 1;
  let r = ge(), E, w;
  class l extends r {
    constructor(g) {
      super({ type: "document", ...g }), this.nodes || (this.nodes = []);
    }
    toResult(g = {}) {
      return new E(new w(), this, g).stringify();
    }
  }
  return l.registerLazyResult = (h) => {
    E = h;
  }, l.registerProcessor = (h) => {
    w = h;
  }, rt = l, l.default = l, rt;
}
var it, Su;
function jr() {
  if (Su) return it;
  Su = 1;
  let r = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  return it = { nanoid: (l = 21) => {
    let h = "", g = l | 0;
    for (; g--; )
      h += r[Math.random() * 64 | 0];
    return h;
  }, customAlphabet: (l, h = 21) => (g = h) => {
    let c = "", f = g | 0;
    for (; f--; )
      c += l[Math.random() * l.length | 0];
    return c;
  } }, it;
}
var nt, Eu;
function Wu() {
  if (Eu) return nt;
  Eu = 1;
  let { existsSync: r, readFileSync: E } = te, { dirname: w, join: l } = te, { SourceMapConsumer: h, SourceMapGenerator: g } = te;
  function c(m) {
    return Buffer ? Buffer.from(m, "base64").toString() : window.atob(m);
  }
  class f {
    constructor(i, u) {
      if (u.map === !1) return;
      this.loadAnnotation(i), this.inline = this.startWith(this.annotation, "data:");
      let o = u.map ? u.map.prev : void 0, e = this.loadMap(u.from, o);
      !this.mapFile && u.from && (this.mapFile = u.from), this.mapFile && (this.root = w(this.mapFile)), e && (this.text = e);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new h(this.text)), this.consumerCache;
    }
    decodeInline(i) {
      let u = /^data:application\/json;charset=utf-?8;base64,/, o = /^data:application\/json;base64,/, e = /^data:application\/json;charset=utf-?8,/, t = /^data:application\/json,/, s = i.match(e) || i.match(t);
      if (s)
        return decodeURIComponent(i.substr(s[0].length));
      let d = i.match(u) || i.match(o);
      if (d)
        return c(i.substr(d[0].length));
      let b = i.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + b);
    }
    getAnnotationURL(i) {
      return i.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(i) {
      return typeof i != "object" ? !1 : typeof i.mappings == "string" || typeof i._mappings == "string" || Array.isArray(i.sections);
    }
    loadAnnotation(i) {
      let u = i.match(/\/\*\s*# sourceMappingURL=/g);
      if (!u) return;
      let o = i.lastIndexOf(u.pop()), e = i.indexOf("*/", o);
      o > -1 && e > -1 && (this.annotation = this.getAnnotationURL(i.substring(o, e)));
    }
    loadFile(i) {
      if (this.root = w(i), r(i))
        return this.mapFile = i, E(i, "utf-8").toString().trim();
    }
    loadMap(i, u) {
      if (u === !1) return !1;
      if (u) {
        if (typeof u == "string")
          return u;
        if (typeof u == "function") {
          let o = u(i);
          if (o) {
            let e = this.loadFile(o);
            if (!e)
              throw new Error(
                "Unable to load previous source map: " + o.toString()
              );
            return e;
          }
        } else {
          if (u instanceof h)
            return g.fromSourceMap(u).toString();
          if (u instanceof g)
            return u.toString();
          if (this.isMap(u))
            return JSON.stringify(u);
          throw new Error(
            "Unsupported previous source map format: " + u.toString()
          );
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let o = this.annotation;
          return i && (o = l(w(i), o)), this.loadFile(o);
        }
      }
    }
    startWith(i, u) {
      return i ? i.substr(0, u.length) === u : !1;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  }
  return nt = f, f.default = f, nt;
}
var at, Tu;
function ke() {
  if (Tu) return at;
  Tu = 1;
  let { nanoid: r } = /* @__PURE__ */ jr(), { isAbsolute: E, resolve: w } = te, { SourceMapConsumer: l, SourceMapGenerator: h } = te, { fileURLToPath: g, pathToFileURL: c } = te, f = Tt(), m = Wu(), i = te, u = Symbol("fromOffsetCache"), o = !!(l && h), e = !!(w && E);
  class t {
    get from() {
      return this.file || this.id;
    }
    constructor(d, b = {}) {
      if (d === null || typeof d > "u" || typeof d == "object" && !d.toString)
        throw new Error(`PostCSS received ${d} instead of CSS string`);
      if (this.css = d.toString(), this.css[0] === "\uFEFF" || this.css[0] === "ï¿¾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, this.document = this.css, b.document && (this.document = b.document.toString()), b.from && (!e || /^\w+:\/\//.test(b.from) || E(b.from) ? this.file = b.from : this.file = w(b.from)), e && o) {
        let n = new m(this.css, b);
        if (n.text) {
          this.map = n;
          let p = n.consumer().file;
          !this.file && p && (this.file = this.mapResolve(p));
        }
      }
      this.file || (this.id = "<input css " + r(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(d, b, n, p = {}) {
      let y, x, a;
      if (b && typeof b == "object") {
        let S = b, A = n;
        if (typeof S.offset == "number") {
          let I = this.fromOffset(S.offset);
          b = I.line, n = I.col;
        } else
          b = S.line, n = S.column;
        if (typeof A.offset == "number") {
          let I = this.fromOffset(A.offset);
          x = I.line, y = I.col;
        } else
          x = A.line, y = A.column;
      } else if (!n) {
        let S = this.fromOffset(b);
        b = S.line, n = S.col;
      }
      let v = this.origin(b, n, x, y);
      return v ? a = new f(
        d,
        v.endLine === void 0 ? v.line : { column: v.column, line: v.line },
        v.endLine === void 0 ? v.column : { column: v.endColumn, line: v.endLine },
        v.source,
        v.file,
        p.plugin
      ) : a = new f(
        d,
        x === void 0 ? b : { column: n, line: b },
        x === void 0 ? n : { column: y, line: x },
        this.css,
        this.file,
        p.plugin
      ), a.input = { column: n, endColumn: y, endLine: x, line: b, source: this.css }, this.file && (c && (a.input.url = c(this.file).toString()), a.input.file = this.file), a;
    }
    fromOffset(d) {
      let b, n;
      if (this[u])
        n = this[u];
      else {
        let y = this.css.split(`
`);
        n = new Array(y.length);
        let x = 0;
        for (let a = 0, v = y.length; a < v; a++)
          n[a] = x, x += y[a].length + 1;
        this[u] = n;
      }
      b = n[n.length - 1];
      let p = 0;
      if (d >= b)
        p = n.length - 1;
      else {
        let y = n.length - 2, x;
        for (; p < y; )
          if (x = p + (y - p >> 1), d < n[x])
            y = x - 1;
          else if (d >= n[x + 1])
            p = x + 1;
          else {
            p = x;
            break;
          }
      }
      return {
        col: d - n[p] + 1,
        line: p + 1
      };
    }
    mapResolve(d) {
      return /^\w+:\/\//.test(d) ? d : w(this.map.consumer().sourceRoot || this.map.root || ".", d);
    }
    origin(d, b, n, p) {
      if (!this.map) return !1;
      let y = this.map.consumer(), x = y.originalPositionFor({ column: b, line: d });
      if (!x.source) return !1;
      let a;
      typeof n == "number" && (a = y.originalPositionFor({ column: p, line: n }));
      let v;
      E(x.source) ? v = c(x.source) : v = new URL(
        x.source,
        this.map.consumer().sourceRoot || c(this.map.mapFile)
      );
      let S = {
        column: x.column,
        endColumn: a && a.column,
        endLine: a && a.line,
        line: x.line,
        url: v.toString()
      };
      if (v.protocol === "file:")
        if (g)
          S.file = g(v);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let A = y.sourceContentFor(x.source);
      return A && (S.source = A), S;
    }
    toJSON() {
      let d = {};
      for (let b of ["hasBOM", "css", "file", "id"])
        this[b] != null && (d[b] = this[b]);
      return this.map && (d.map = { ...this.map }, d.map.consumerCache && (d.map.consumerCache = void 0)), d;
    }
  }
  return at = t, t.default = t, i && i.registerInput && i.registerInput(t), at;
}
var st, Au;
function we() {
  if (Au) return st;
  Au = 1;
  let r = ge(), E, w;
  class l extends r {
    constructor(g) {
      super(g), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(g, c, f) {
      let m = super.normalize(g);
      if (c) {
        if (f === "prepend")
          this.nodes.length > 1 ? c.raws.before = this.nodes[1].raws.before : delete c.raws.before;
        else if (this.first !== c)
          for (let i of m)
            i.raws.before = c.raws.before;
      }
      return m;
    }
    removeChild(g, c) {
      let f = this.index(g);
      return !c && f === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[f].raws.before), super.removeChild(g);
    }
    toResult(g = {}) {
      return new E(new w(), this, g).stringify();
    }
  }
  return l.registerLazyResult = (h) => {
    E = h;
  }, l.registerProcessor = (h) => {
    w = h;
  }, st = l, l.default = l, r.registerRoot(l), st;
}
var ot, Ou;
function $u() {
  if (Ou) return ot;
  Ou = 1;
  let r = {
    comma(E) {
      return r.split(E, [","], !0);
    },
    space(E) {
      let w = [" ", `
`, "	"];
      return r.split(E, w);
    },
    split(E, w, l) {
      let h = [], g = "", c = !1, f = 0, m = !1, i = "", u = !1;
      for (let o of E)
        u ? u = !1 : o === "\\" ? u = !0 : m ? o === i && (m = !1) : o === '"' || o === "'" ? (m = !0, i = o) : o === "(" ? f += 1 : o === ")" ? f > 0 && (f -= 1) : f === 0 && w.includes(o) && (c = !0), c ? (g !== "" && h.push(g.trim()), g = "", c = !1) : g += o;
      return (l || g !== "") && h.push(g.trim()), h;
    }
  };
  return ot = r, r.default = r, ot;
}
var ct, Nu;
function _t() {
  if (Nu) return ct;
  Nu = 1;
  let r = ge(), E = $u();
  class w extends r {
    get selectors() {
      return E.comma(this.selector);
    }
    set selectors(h) {
      let g = this.selector ? this.selector.match(/,\s*/) : null, c = g ? g[0] : "," + this.raw("between", "beforeOpen");
      this.selector = h.join(c);
    }
    constructor(h) {
      super(h), this.type = "rule", this.nodes || (this.nodes = []);
    }
  }
  return ct = w, w.default = w, r.registerRule(w), ct;
}
var lt, _u;
function Br() {
  if (_u) return lt;
  _u = 1;
  let r = Ot(), E = Re(), w = Me(), l = ke(), h = Wu(), g = we(), c = _t();
  function f(m, i) {
    if (Array.isArray(m)) return m.map((e) => f(e));
    let { inputs: u, ...o } = m;
    if (u) {
      i = [];
      for (let e of u) {
        let t = { ...e, __proto__: l.prototype };
        t.map && (t.map = {
          ...t.map,
          __proto__: h.prototype
        }), i.push(t);
      }
    }
    if (o.nodes && (o.nodes = m.nodes.map((e) => f(e, i))), o.source) {
      let { inputId: e, ...t } = o.source;
      o.source = t, e != null && (o.source.input = i[e]);
    }
    if (o.type === "root")
      return new g(o);
    if (o.type === "decl")
      return new w(o);
    if (o.type === "rule")
      return new c(o);
    if (o.type === "comment")
      return new E(o);
    if (o.type === "atrule")
      return new r(o);
    throw new Error("Unknown node type: " + m.type);
  }
  return lt = f, f.default = f, lt;
}
var ft, Iu;
function Xu() {
  if (Iu) return ft;
  Iu = 1;
  let { dirname: r, relative: E, resolve: w, sep: l } = te, { SourceMapConsumer: h, SourceMapGenerator: g } = te, { pathToFileURL: c } = te, f = ke(), m = !!(h && g), i = !!(r && w && E && l);
  class u {
    constructor(e, t, s, d) {
      this.stringify = e, this.mapOpts = s.map || {}, this.root = t, this.opts = s, this.css = d, this.originalCSS = d, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
    }
    addAnnotation() {
      let e;
      this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
      let t = `
`;
      this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
    }
    applyPrevMaps() {
      for (let e of this.previous()) {
        let t = this.toUrl(this.path(e.file)), s = e.root || r(e.file), d;
        this.mapOpts.sourcesContent === !1 ? (d = new h(e.text), d.sourcesContent && (d.sourcesContent = null)) : d = e.consumer(), this.map.applySourceMap(d, t, this.toUrl(this.path(s)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== !1)
        if (this.root) {
          let e;
          for (let t = this.root.nodes.length - 1; t >= 0; t--)
            e = this.root.nodes[t], e.type === "comment" && e.text.startsWith("# sourceMappingURL=") && this.root.removeChild(t);
        } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), i && m && this.isMap())
        return this.generateMap();
      {
        let e = "";
        return this.stringify(this.root, (t) => {
          e += t;
        }), [e];
      }
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let e = this.previous()[0].consumer();
        e.file = this.outputFile(), this.map = g.fromSourceMap(e, {
          ignoreInvalidMapping: !0
        });
      } else
        this.map = new g({
          file: this.outputFile(),
          ignoreInvalidMapping: !0
        }), this.map.addMapping({
          generated: { column: 0, line: 1 },
          original: { column: 0, line: 1 },
          source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
        });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new g({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      });
      let e = 1, t = 1, s = "<no source>", d = {
        generated: { column: 0, line: 0 },
        original: { column: 0, line: 0 },
        source: ""
      }, b, n;
      this.stringify(this.root, (p, y, x) => {
        if (this.css += p, y && x !== "end" && (d.generated.line = e, d.generated.column = t - 1, y.source && y.source.start ? (d.source = this.sourcePath(y), d.original.line = y.source.start.line, d.original.column = y.source.start.column - 1, this.map.addMapping(d)) : (d.source = s, d.original.line = 1, d.original.column = 0, this.map.addMapping(d))), n = p.match(/\n/g), n ? (e += n.length, b = p.lastIndexOf(`
`), t = p.length - b) : t += p.length, y && x !== "start") {
          let a = y.parent || { raws: {} };
          (!(y.type === "decl" || y.type === "atrule" && !y.nodes) || y !== a.last || a.raws.semicolon) && (y.source && y.source.end ? (d.source = this.sourcePath(y), d.original.line = y.source.end.line, d.original.column = y.source.end.column - 1, d.generated.line = e, d.generated.column = t - 2, this.map.addMapping(d)) : (d.source = s, d.original.line = 1, d.original.column = 0, d.generated.line = e, d.generated.column = t - 1, this.map.addMapping(d)));
        }
      });
    }
    isAnnotation() {
      return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let e = this.mapOpts.annotation;
      return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(e) {
      if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
      let t = this.memoizedPaths.get(e);
      if (t) return t;
      let s = this.opts.to ? r(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (s = r(w(s, this.mapOpts.annotation)));
      let d = E(s, e);
      return this.memoizedPaths.set(e, d), d;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((e) => {
            if (e.source && e.source.input.map) {
              let t = e.source.input.map;
              this.previousMaps.includes(t) || this.previousMaps.push(t);
            }
          });
        else {
          let e = new f(this.originalCSS, this.opts);
          e.map && this.previousMaps.push(e.map);
        }
      return this.previousMaps;
    }
    setSourcesContent() {
      let e = {};
      if (this.root)
        this.root.walk((t) => {
          if (t.source) {
            let s = t.source.input.from;
            if (s && !e[s]) {
              e[s] = !0;
              let d = this.usesFileUrls ? this.toFileUrl(s) : this.toUrl(this.path(s));
              this.map.setSourceContent(d, t.source.input.css);
            }
          }
        });
      else if (this.css) {
        let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(t, this.css);
      }
    }
    sourcePath(e) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
    }
    toBase64(e) {
      return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
    }
    toFileUrl(e) {
      let t = this.memoizedFileURLs.get(e);
      if (t) return t;
      if (c) {
        let s = c(e).toString();
        return this.memoizedFileURLs.set(e, s), s;
      } else
        throw new Error(
          "`map.absolute` option is not available in this PostCSS build"
        );
    }
    toUrl(e) {
      let t = this.memoizedURLs.get(e);
      if (t) return t;
      l === "\\" && (e = e.replace(/\\/g, "/"));
      let s = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(e, s), s;
    }
  }
  return ft = u, ft;
}
var dt, qu;
function Ur() {
  if (qu) return dt;
  qu = 1;
  const r = 39, E = 34, w = 92, l = 47, h = 10, g = 32, c = 12, f = 9, m = 13, i = 91, u = 93, o = 40, e = 41, t = 123, s = 125, d = 59, b = 42, n = 58, p = 64, y = /[\t\n\f\r "#'()/;[\\\]{}]/g, x = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, a = /.[\r\n"'(/\\]/, v = /[\da-f]/i;
  return dt = function(A, I = {}) {
    let q = A.css.valueOf(), T = I.ignoreErrors, O, D, L, N, j, B, F, G, W, ue, ye = q.length, R = 0, re = [], de = [];
    function Se() {
      return R;
    }
    function ve(_) {
      throw A.error("Unclosed " + _, R);
    }
    function je() {
      return de.length === 0 && R >= ye;
    }
    function Be(_) {
      if (de.length) return de.pop();
      if (R >= ye) return;
      let P = _ ? _.ignoreUnclosed : !1;
      switch (O = q.charCodeAt(R), O) {
        case h:
        case g:
        case f:
        case m:
        case c: {
          N = R;
          do
            N += 1, O = q.charCodeAt(N);
          while (O === g || O === h || O === f || O === m || O === c);
          B = ["space", q.slice(R, N)], R = N - 1;
          break;
        }
        case i:
        case u:
        case t:
        case s:
        case n:
        case d:
        case e: {
          let C = String.fromCharCode(O);
          B = [C, C, R];
          break;
        }
        case o: {
          if (ue = re.length ? re.pop()[1] : "", W = q.charCodeAt(R + 1), ue === "url" && W !== r && W !== E && W !== g && W !== h && W !== f && W !== c && W !== m) {
            N = R;
            do {
              if (F = !1, N = q.indexOf(")", N + 1), N === -1)
                if (T || P) {
                  N = R;
                  break;
                } else
                  ve("bracket");
              for (G = N; q.charCodeAt(G - 1) === w; )
                G -= 1, F = !F;
            } while (F);
            B = ["brackets", q.slice(R, N + 1), R, N], R = N;
          } else
            N = q.indexOf(")", R + 1), D = q.slice(R, N + 1), N === -1 || a.test(D) ? B = ["(", "(", R] : (B = ["brackets", D, R, N], R = N);
          break;
        }
        case r:
        case E: {
          j = O === r ? "'" : '"', N = R;
          do {
            if (F = !1, N = q.indexOf(j, N + 1), N === -1)
              if (T || P) {
                N = R + 1;
                break;
              } else
                ve("string");
            for (G = N; q.charCodeAt(G - 1) === w; )
              G -= 1, F = !F;
          } while (F);
          B = ["string", q.slice(R, N + 1), R, N], R = N;
          break;
        }
        case p: {
          y.lastIndex = R + 1, y.test(q), y.lastIndex === 0 ? N = q.length - 1 : N = y.lastIndex - 2, B = ["at-word", q.slice(R, N + 1), R, N], R = N;
          break;
        }
        case w: {
          for (N = R, L = !0; q.charCodeAt(N + 1) === w; )
            N += 1, L = !L;
          if (O = q.charCodeAt(N + 1), L && O !== l && O !== g && O !== h && O !== f && O !== m && O !== c && (N += 1, v.test(q.charAt(N)))) {
            for (; v.test(q.charAt(N + 1)); )
              N += 1;
            q.charCodeAt(N + 1) === g && (N += 1);
          }
          B = ["word", q.slice(R, N + 1), R, N], R = N;
          break;
        }
        default: {
          O === l && q.charCodeAt(R + 1) === b ? (N = q.indexOf("*/", R + 2) + 1, N === 0 && (T || P ? N = q.length : ve("comment")), B = ["comment", q.slice(R, N + 1), R, N], R = N) : (x.lastIndex = R + 1, x.test(q), x.lastIndex === 0 ? N = q.length - 1 : N = x.lastIndex - 2, B = ["word", q.slice(R, N + 1), R, N], re.push(B), R = N);
          break;
        }
      }
      return R++, B;
    }
    function Ee(_) {
      de.push(_);
    }
    return {
      back: Ee,
      endOfFile: je,
      nextToken: Be,
      position: Se
    };
  }, dt;
}
var ht, Cu;
function Hr() {
  if (Cu) return ht;
  Cu = 1;
  let r = Ot(), E = Re(), w = Me(), l = we(), h = _t(), g = Ur();
  const c = {
    empty: !0,
    space: !0
  };
  function f(i) {
    for (let u = i.length - 1; u >= 0; u--) {
      let o = i[u], e = o[3] || o[2];
      if (e) return e;
    }
  }
  class m {
    constructor(u) {
      this.input = u, this.root = new l(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: u, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(u) {
      let o = new r();
      o.name = u[1].slice(1), o.name === "" && this.unnamedAtrule(o, u), this.init(o, u[2]);
      let e, t, s, d = !1, b = !1, n = [], p = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (u = this.tokenizer.nextToken(), e = u[0], e === "(" || e === "[" ? p.push(e === "(" ? ")" : "]") : e === "{" && p.length > 0 ? p.push("}") : e === p[p.length - 1] && p.pop(), p.length === 0)
          if (e === ";") {
            o.source.end = this.getPosition(u[2]), o.source.end.offset++, this.semicolon = !0;
            break;
          } else if (e === "{") {
            b = !0;
            break;
          } else if (e === "}") {
            if (n.length > 0) {
              for (s = n.length - 1, t = n[s]; t && t[0] === "space"; )
                t = n[--s];
              t && (o.source.end = this.getPosition(t[3] || t[2]), o.source.end.offset++);
            }
            this.end(u);
            break;
          } else
            n.push(u);
        else
          n.push(u);
        if (this.tokenizer.endOfFile()) {
          d = !0;
          break;
        }
      }
      o.raws.between = this.spacesAndCommentsFromEnd(n), n.length ? (o.raws.afterName = this.spacesAndCommentsFromStart(n), this.raw(o, "params", n), d && (u = n[n.length - 1], o.source.end = this.getPosition(u[3] || u[2]), o.source.end.offset++, this.spaces = o.raws.between, o.raws.between = "")) : (o.raws.afterName = "", o.params = ""), b && (o.nodes = [], this.current = o);
    }
    checkMissedSemicolon(u) {
      let o = this.colon(u);
      if (o === !1) return;
      let e = 0, t;
      for (let s = o - 1; s >= 0 && (t = u[s], !(t[0] !== "space" && (e += 1, e === 2))); s--)
        ;
      throw this.input.error(
        "Missed semicolon",
        t[0] === "word" ? t[3] + 1 : t[2]
      );
    }
    colon(u) {
      let o = 0, e, t, s;
      for (let [d, b] of u.entries()) {
        if (t = b, s = t[0], s === "(" && (o += 1), s === ")" && (o -= 1), o === 0 && s === ":")
          if (!e)
            this.doubleColon(t);
          else {
            if (e[0] === "word" && e[1] === "progid")
              continue;
            return d;
          }
        e = t;
      }
      return !1;
    }
    comment(u) {
      let o = new E();
      this.init(o, u[2]), o.source.end = this.getPosition(u[3] || u[2]), o.source.end.offset++;
      let e = u[1].slice(2, -2);
      if (/^\s*$/.test(e))
        o.text = "", o.raws.left = e, o.raws.right = "";
      else {
        let t = e.match(/^(\s*)([^]*\S)(\s*)$/);
        o.text = t[2], o.raws.left = t[1], o.raws.right = t[3];
      }
    }
    createTokenizer() {
      this.tokenizer = g(this.input);
    }
    decl(u, o) {
      let e = new w();
      this.init(e, u[0][2]);
      let t = u[u.length - 1];
      for (t[0] === ";" && (this.semicolon = !0, u.pop()), e.source.end = this.getPosition(
        t[3] || t[2] || f(u)
      ), e.source.end.offset++; u[0][0] !== "word"; )
        u.length === 1 && this.unknownWord(u), e.raws.before += u.shift()[1];
      for (e.source.start = this.getPosition(u[0][2]), e.prop = ""; u.length; ) {
        let p = u[0][0];
        if (p === ":" || p === "space" || p === "comment")
          break;
        e.prop += u.shift()[1];
      }
      e.raws.between = "";
      let s;
      for (; u.length; )
        if (s = u.shift(), s[0] === ":") {
          e.raws.between += s[1];
          break;
        } else
          s[0] === "word" && /\w/.test(s[1]) && this.unknownWord([s]), e.raws.between += s[1];
      (e.prop[0] === "_" || e.prop[0] === "*") && (e.raws.before += e.prop[0], e.prop = e.prop.slice(1));
      let d = [], b;
      for (; u.length && (b = u[0][0], !(b !== "space" && b !== "comment")); )
        d.push(u.shift());
      this.precheckMissedSemicolon(u);
      for (let p = u.length - 1; p >= 0; p--) {
        if (s = u[p], s[1].toLowerCase() === "!important") {
          e.important = !0;
          let y = this.stringFrom(u, p);
          y = this.spacesFromEnd(u) + y, y !== " !important" && (e.raws.important = y);
          break;
        } else if (s[1].toLowerCase() === "important") {
          let y = u.slice(0), x = "";
          for (let a = p; a > 0; a--) {
            let v = y[a][0];
            if (x.trim().startsWith("!") && v !== "space")
              break;
            x = y.pop()[1] + x;
          }
          x.trim().startsWith("!") && (e.important = !0, e.raws.important = x, u = y);
        }
        if (s[0] !== "space" && s[0] !== "comment")
          break;
      }
      u.some((p) => p[0] !== "space" && p[0] !== "comment") && (e.raws.between += d.map((p) => p[1]).join(""), d = []), this.raw(e, "value", d.concat(u), o), e.value.includes(":") && !o && this.checkMissedSemicolon(u);
    }
    doubleColon(u) {
      throw this.input.error(
        "Double colon",
        { offset: u[2] },
        { offset: u[2] + u[1].length }
      );
    }
    emptyRule(u) {
      let o = new h();
      this.init(o, u[2]), o.selector = "", o.raws.between = "", this.current = o;
    }
    end(u) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(u[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(u);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(u) {
      if (this.spaces += u[1], this.current.nodes) {
        let o = this.current.nodes[this.current.nodes.length - 1];
        o && o.type === "rule" && !o.raws.ownSemicolon && (o.raws.ownSemicolon = this.spaces, this.spaces = "", o.source.end = this.getPosition(u[2]), o.source.end.offset += o.raws.ownSemicolon.length);
      }
    }
    // Helpers
    getPosition(u) {
      let o = this.input.fromOffset(u);
      return {
        column: o.col,
        line: o.line,
        offset: u
      };
    }
    init(u, o) {
      this.current.push(u), u.source = {
        input: this.input,
        start: this.getPosition(o)
      }, u.raws.before = this.spaces, this.spaces = "", u.type !== "comment" && (this.semicolon = !1);
    }
    other(u) {
      let o = !1, e = null, t = !1, s = null, d = [], b = u[1].startsWith("--"), n = [], p = u;
      for (; p; ) {
        if (e = p[0], n.push(p), e === "(" || e === "[")
          s || (s = p), d.push(e === "(" ? ")" : "]");
        else if (b && t && e === "{")
          s || (s = p), d.push("}");
        else if (d.length === 0)
          if (e === ";")
            if (t) {
              this.decl(n, b);
              return;
            } else
              break;
          else if (e === "{") {
            this.rule(n);
            return;
          } else if (e === "}") {
            this.tokenizer.back(n.pop()), o = !0;
            break;
          } else e === ":" && (t = !0);
        else e === d[d.length - 1] && (d.pop(), d.length === 0 && (s = null));
        p = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (o = !0), d.length > 0 && this.unclosedBracket(s), o && t) {
        if (!b)
          for (; n.length && (p = n[n.length - 1][0], !(p !== "space" && p !== "comment")); )
            this.tokenizer.back(n.pop());
        this.decl(n, b);
      } else
        this.unknownWord(n);
    }
    parse() {
      let u;
      for (; !this.tokenizer.endOfFile(); )
        switch (u = this.tokenizer.nextToken(), u[0]) {
          case "space":
            this.spaces += u[1];
            break;
          case ";":
            this.freeSemicolon(u);
            break;
          case "}":
            this.end(u);
            break;
          case "comment":
            this.comment(u);
            break;
          case "at-word":
            this.atrule(u);
            break;
          case "{":
            this.emptyRule(u);
            break;
          default:
            this.other(u);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(u, o, e, t) {
      let s, d, b = e.length, n = "", p = !0, y, x;
      for (let a = 0; a < b; a += 1)
        s = e[a], d = s[0], d === "space" && a === b - 1 && !t ? p = !1 : d === "comment" ? (x = e[a - 1] ? e[a - 1][0] : "empty", y = e[a + 1] ? e[a + 1][0] : "empty", !c[x] && !c[y] ? n.slice(-1) === "," ? p = !1 : n += s[1] : p = !1) : n += s[1];
      if (!p) {
        let a = e.reduce((v, S) => v + S[1], "");
        u.raws[o] = { raw: a, value: n };
      }
      u[o] = n;
    }
    rule(u) {
      u.pop();
      let o = new h();
      this.init(o, u[0][2]), o.raws.between = this.spacesAndCommentsFromEnd(u), this.raw(o, "selector", u), this.current = o;
    }
    spacesAndCommentsFromEnd(u) {
      let o, e = "";
      for (; u.length && (o = u[u.length - 1][0], !(o !== "space" && o !== "comment")); )
        e = u.pop()[1] + e;
      return e;
    }
    // Errors
    spacesAndCommentsFromStart(u) {
      let o, e = "";
      for (; u.length && (o = u[0][0], !(o !== "space" && o !== "comment")); )
        e += u.shift()[1];
      return e;
    }
    spacesFromEnd(u) {
      let o, e = "";
      for (; u.length && (o = u[u.length - 1][0], o === "space"); )
        e = u.pop()[1] + e;
      return e;
    }
    stringFrom(u, o) {
      let e = "";
      for (let t = o; t < u.length; t++)
        e += u[t][1];
      return u.splice(o, u.length - o), e;
    }
    unclosedBlock() {
      let u = this.current.source.start;
      throw this.input.error("Unclosed block", u.line, u.column);
    }
    unclosedBracket(u) {
      throw this.input.error(
        "Unclosed bracket",
        { offset: u[2] },
        { offset: u[2] + 1 }
      );
    }
    unexpectedClose(u) {
      throw this.input.error(
        "Unexpected }",
        { offset: u[2] },
        { offset: u[2] + 1 }
      );
    }
    unknownWord(u) {
      throw this.input.error(
        "Unknown word " + u[0][1],
        { offset: u[0][2] },
        { offset: u[0][2] + u[0][1].length }
      );
    }
    unnamedAtrule(u, o) {
      throw this.input.error(
        "At-rule without name",
        { offset: o[2] },
        { offset: o[2] + o[1].length }
      );
    }
  }
  return ht = m, ht;
}
var pt, Du;
function It() {
  if (Du) return pt;
  Du = 1;
  let r = ge(), E = ke(), w = Hr();
  function l(h, g) {
    let c = new E(h, g), f = new w(c);
    try {
      f.parse();
    } catch (m) {
      throw process.env.NODE_ENV !== "production" && m.name === "CssSyntaxError" && g && g.from && (/\.scss$/i.test(g.from) ? m.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(g.from) ? m.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(g.from) && (m.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), m;
    }
    return f.root;
  }
  return pt = l, l.default = l, r.registerParse(l), pt;
}
var bt, Pu;
function Qu() {
  if (Pu) return bt;
  Pu = 1;
  class r {
    constructor(w, l = {}) {
      if (this.type = "warning", this.text = w, l.node && l.node.source) {
        let h = l.node.rangeBy(l);
        this.line = h.start.line, this.column = h.start.column, this.endLine = h.end.line, this.endColumn = h.end.column;
      }
      for (let h in l) this[h] = l[h];
    }
    toString() {
      return this.node ? this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  }
  return bt = r, r.default = r, bt;
}
var mt, Lu;
function qt() {
  if (Lu) return mt;
  Lu = 1;
  let r = Qu();
  class E {
    get content() {
      return this.css;
    }
    constructor(l, h, g) {
      this.processor = l, this.messages = [], this.root = h, this.opts = g, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(l, h = {}) {
      h.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (h.plugin = this.lastPlugin.postcssPlugin);
      let g = new r(l, h);
      return this.messages.push(g), g;
    }
    warnings() {
      return this.messages.filter((l) => l.type === "warning");
    }
  }
  return mt = E, E.default = E, mt;
}
var gt, Ru;
function Ju() {
  if (Ru) return gt;
  Ru = 1;
  let r = {};
  return gt = function(w) {
    r[w] || (r[w] = !0, typeof console < "u" && console.warn && console.warn(w));
  }, gt;
}
var yt, Mu;
function Zu() {
  if (Mu) return yt;
  Mu = 1;
  let r = ge(), E = Nt(), w = Xu(), l = It(), h = qt(), g = we(), c = Pe(), { isClean: f, my: m } = At(), i = Ju();
  const u = {
    atrule: "AtRule",
    comment: "Comment",
    decl: "Declaration",
    document: "Document",
    root: "Root",
    rule: "Rule"
  }, o = {
    AtRule: !0,
    AtRuleExit: !0,
    Comment: !0,
    CommentExit: !0,
    Declaration: !0,
    DeclarationExit: !0,
    Document: !0,
    DocumentExit: !0,
    Once: !0,
    OnceExit: !0,
    postcssPlugin: !0,
    prepare: !0,
    Root: !0,
    RootExit: !0,
    Rule: !0,
    RuleExit: !0
  }, e = {
    Once: !0,
    postcssPlugin: !0,
    prepare: !0
  }, t = 0;
  function s(x) {
    return typeof x == "object" && typeof x.then == "function";
  }
  function d(x) {
    let a = !1, v = u[x.type];
    return x.type === "decl" ? a = x.prop.toLowerCase() : x.type === "atrule" && (a = x.name.toLowerCase()), a && x.append ? [
      v,
      v + "-" + a,
      t,
      v + "Exit",
      v + "Exit-" + a
    ] : a ? [v, v + "-" + a, v + "Exit", v + "Exit-" + a] : x.append ? [v, t, v + "Exit"] : [v, v + "Exit"];
  }
  function b(x) {
    let a;
    return x.type === "document" ? a = ["Document", t, "DocumentExit"] : x.type === "root" ? a = ["Root", t, "RootExit"] : a = d(x), {
      eventIndex: 0,
      events: a,
      iterator: 0,
      node: x,
      visitorIndex: 0,
      visitors: []
    };
  }
  function n(x) {
    return x[f] = !1, x.nodes && x.nodes.forEach((a) => n(a)), x;
  }
  let p = {};
  class y {
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
    constructor(a, v, S) {
      this.stringified = !1, this.processed = !1;
      let A;
      if (typeof v == "object" && v !== null && (v.type === "root" || v.type === "document"))
        A = n(v);
      else if (v instanceof y || v instanceof h)
        A = n(v.root), v.map && (typeof S.map > "u" && (S.map = {}), S.map.inline || (S.map.inline = !1), S.map.prev = v.map);
      else {
        let I = l;
        S.syntax && (I = S.syntax.parse), S.parser && (I = S.parser), I.parse && (I = I.parse);
        try {
          A = I(v, S);
        } catch (q) {
          this.processed = !0, this.error = q;
        }
        A && !A[m] && r.rebuild(A);
      }
      this.result = new h(a, A, S), this.helpers = { ...p, postcss: p, result: this.result }, this.plugins = this.processor.plugins.map((I) => typeof I == "object" && I.prepare ? { ...I, ...I.prepare(this.result) } : I);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(a) {
      return this.async().catch(a);
    }
    finally(a) {
      return this.async().then(a, a);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(a, v) {
      let S = this.result.lastPlugin;
      try {
        if (v && v.addToError(a), this.error = a, a.name === "CssSyntaxError" && !a.plugin)
          a.plugin = S.postcssPlugin, a.setMessage();
        else if (S.postcssVersion && process.env.NODE_ENV !== "production") {
          let A = S.postcssPlugin, I = S.postcssVersion, q = this.result.processor.version, T = I.split("."), O = q.split(".");
          (T[0] !== O[0] || parseInt(T[1]) > parseInt(O[1])) && console.error(
            "Unknown error from PostCSS plugin. Your current PostCSS version is " + q + ", but " + A + " uses " + I + ". Perhaps this is the source of the error below."
          );
        }
      } catch (A) {
        console && console.error && console.error(A);
      }
      return a;
    }
    prepareVisitors() {
      this.listeners = {};
      let a = (v, S, A) => {
        this.listeners[S] || (this.listeners[S] = []), this.listeners[S].push([v, A]);
      };
      for (let v of this.plugins)
        if (typeof v == "object")
          for (let S in v) {
            if (!o[S] && /^[A-Z]/.test(S))
              throw new Error(
                `Unknown event ${S} in ${v.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
              );
            if (!e[S])
              if (typeof v[S] == "object")
                for (let A in v[S])
                  A === "*" ? a(v, S, v[S][A]) : a(
                    v,
                    S + "-" + A.toLowerCase(),
                    v[S][A]
                  );
              else typeof v[S] == "function" && a(v, S, v[S]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let a = 0; a < this.plugins.length; a++) {
        let v = this.plugins[a], S = this.runOnRoot(v);
        if (s(S))
          try {
            await S;
          } catch (A) {
            throw this.handleError(A);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let a = this.result.root;
        for (; !a[f]; ) {
          a[f] = !0;
          let v = [b(a)];
          for (; v.length > 0; ) {
            let S = this.visitTick(v);
            if (s(S))
              try {
                await S;
              } catch (A) {
                let I = v[v.length - 1].node;
                throw this.handleError(A, I);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [v, S] of this.listeners.OnceExit) {
            this.result.lastPlugin = v;
            try {
              if (a.type === "document") {
                let A = a.nodes.map(
                  (I) => S(I, this.helpers)
                );
                await Promise.all(A);
              } else
                await S(a, this.helpers);
            } catch (A) {
              throw this.handleError(A);
            }
          }
      }
      return this.processed = !0, this.stringify();
    }
    runOnRoot(a) {
      this.result.lastPlugin = a;
      try {
        if (typeof a == "object" && a.Once) {
          if (this.result.root.type === "document") {
            let v = this.result.root.nodes.map(
              (S) => a.Once(S, this.helpers)
            );
            return s(v[0]) ? Promise.all(v) : v;
          }
          return a.Once(this.result.root, this.helpers);
        } else if (typeof a == "function")
          return a(this.result.root, this.result);
      } catch (v) {
        throw this.handleError(v);
      }
    }
    stringify() {
      if (this.error) throw this.error;
      if (this.stringified) return this.result;
      this.stringified = !0, this.sync();
      let a = this.result.opts, v = c;
      a.syntax && (v = a.syntax.stringify), a.stringifier && (v = a.stringifier), v.stringify && (v = v.stringify);
      let A = new w(v, this.result.root, this.result.opts).generate();
      return this.result.css = A[0], this.result.map = A[1], this.result;
    }
    sync() {
      if (this.error) throw this.error;
      if (this.processed) return this.result;
      if (this.processed = !0, this.processing)
        throw this.getAsyncError();
      for (let a of this.plugins) {
        let v = this.runOnRoot(a);
        if (s(v))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let a = this.result.root;
        for (; !a[f]; )
          a[f] = !0, this.walkSync(a);
        if (this.listeners.OnceExit)
          if (a.type === "document")
            for (let v of a.nodes)
              this.visitSync(this.listeners.OnceExit, v);
          else
            this.visitSync(this.listeners.OnceExit, a);
      }
      return this.result;
    }
    then(a, v) {
      return process.env.NODE_ENV !== "production" && ("from" in this.opts || i(
        "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
      )), this.async().then(a, v);
    }
    toString() {
      return this.css;
    }
    visitSync(a, v) {
      for (let [S, A] of a) {
        this.result.lastPlugin = S;
        let I;
        try {
          I = A(v, this.helpers);
        } catch (q) {
          throw this.handleError(q, v.proxyOf);
        }
        if (v.type !== "root" && v.type !== "document" && !v.parent)
          return !0;
        if (s(I))
          throw this.getAsyncError();
      }
    }
    visitTick(a) {
      let v = a[a.length - 1], { node: S, visitors: A } = v;
      if (S.type !== "root" && S.type !== "document" && !S.parent) {
        a.pop();
        return;
      }
      if (A.length > 0 && v.visitorIndex < A.length) {
        let [q, T] = A[v.visitorIndex];
        v.visitorIndex += 1, v.visitorIndex === A.length && (v.visitors = [], v.visitorIndex = 0), this.result.lastPlugin = q;
        try {
          return T(S.toProxy(), this.helpers);
        } catch (O) {
          throw this.handleError(O, S);
        }
      }
      if (v.iterator !== 0) {
        let q = v.iterator, T;
        for (; T = S.nodes[S.indexes[q]]; )
          if (S.indexes[q] += 1, !T[f]) {
            T[f] = !0, a.push(b(T));
            return;
          }
        v.iterator = 0, delete S.indexes[q];
      }
      let I = v.events;
      for (; v.eventIndex < I.length; ) {
        let q = I[v.eventIndex];
        if (v.eventIndex += 1, q === t) {
          S.nodes && S.nodes.length && (S[f] = !0, v.iterator = S.getIterator());
          return;
        } else if (this.listeners[q]) {
          v.visitors = this.listeners[q];
          return;
        }
      }
      a.pop();
    }
    walkSync(a) {
      a[f] = !0;
      let v = d(a);
      for (let S of v)
        if (S === t)
          a.nodes && a.each((A) => {
            A[f] || this.walkSync(A);
          });
        else {
          let A = this.listeners[S];
          if (A && this.visitSync(A, a.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
  }
  return y.registerPostcss = (x) => {
    p = x;
  }, yt = y, y.default = y, g.registerLazyResult(y), E.registerLazyResult(y), yt;
}
var vt, ku;
function Fr() {
  if (ku) return vt;
  ku = 1;
  let r = Xu(), E = It();
  const w = qt();
  let l = Pe(), h = Ju();
  class g {
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let f, m = E;
      try {
        f = m(this._css, this._opts);
      } catch (i) {
        this.error = i;
      }
      if (this.error)
        throw this.error;
      return this._root = f, f;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
    constructor(f, m, i) {
      m = m.toString(), this.stringified = !1, this._processor = f, this._css = m, this._opts = i, this._map = void 0;
      let u, o = l;
      this.result = new w(this._processor, u, this._opts), this.result.css = m;
      let e = this;
      Object.defineProperty(this.result, "root", {
        get() {
          return e.root;
        }
      });
      let t = new r(o, u, this._opts, m);
      if (t.isMap()) {
        let [s, d] = t.generate();
        s && (this.result.css = s), d && (this.result.map = d);
      } else
        t.clearAnnotation(), this.result.css = t.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(f) {
      return this.async().catch(f);
    }
    finally(f) {
      return this.async().then(f, f);
    }
    sync() {
      if (this.error) throw this.error;
      return this.result;
    }
    then(f, m) {
      return process.env.NODE_ENV !== "production" && ("from" in this._opts || h(
        "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
      )), this.async().then(f, m);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
  }
  return vt = g, g.default = g, vt;
}
var xt, ju;
function Vr() {
  if (ju) return xt;
  ju = 1;
  let r = Nt(), E = Zu(), w = Fr(), l = we();
  class h {
    constructor(c = []) {
      this.version = "8.5.3", this.plugins = this.normalize(c);
    }
    normalize(c) {
      let f = [];
      for (let m of c)
        if (m.postcss === !0 ? m = m() : m.postcss && (m = m.postcss), typeof m == "object" && Array.isArray(m.plugins))
          f = f.concat(m.plugins);
        else if (typeof m == "object" && m.postcssPlugin)
          f.push(m);
        else if (typeof m == "function")
          f.push(m);
        else if (typeof m == "object" && (m.parse || m.stringify)) {
          if (process.env.NODE_ENV !== "production")
            throw new Error(
              "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
            );
        } else
          throw new Error(m + " is not a PostCSS plugin");
      return f;
    }
    process(c, f = {}) {
      return !this.plugins.length && !f.parser && !f.stringifier && !f.syntax ? new w(this, c, f) : new E(this, c, f);
    }
    use(c) {
      return this.plugins = this.plugins.concat(this.normalize([c])), this;
    }
  }
  return xt = h, h.default = h, l.registerProcessor(h), r.registerProcessor(h), xt;
}
var wt, Bu;
function zr() {
  if (Bu) return wt;
  Bu = 1;
  let r = Ot(), E = Re(), w = ge(), l = Tt(), h = Me(), g = Nt(), c = Br(), f = ke(), m = Zu(), i = $u(), u = Le(), o = It(), e = Vr(), t = qt(), s = we(), d = _t(), b = Pe(), n = Qu();
  function p(...y) {
    return y.length === 1 && Array.isArray(y[0]) && (y = y[0]), new e(y);
  }
  return p.plugin = function(x, a) {
    let v = !1;
    function S(...I) {
      console && console.warn && !v && (v = !0, console.warn(
        x + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
      ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
        x + `: é‡Œé¢ postcss.plugin è¢«å¼ƒç”¨. è¿ç§»æŒ‡å—:
https://www.w3ctech.com/topic/2226`
      ));
      let q = a(...I);
      return q.postcssPlugin = x, q.postcssVersion = new e().version, q;
    }
    let A;
    return Object.defineProperty(S, "postcss", {
      get() {
        return A || (A = S()), A;
      }
    }), S.process = function(I, q, T) {
      return p([S(T)]).process(I, q);
    }, S;
  }, p.stringify = b, p.parse = o, p.fromJSON = c, p.list = i, p.comment = (y) => new E(y), p.atRule = (y) => new r(y), p.decl = (y) => new h(y), p.rule = (y) => new d(y), p.root = (y) => new s(y), p.document = (y) => new g(y), p.CssSyntaxError = l, p.Declaration = h, p.Container = w, p.Processor = e, p.Document = g, p.Comment = E, p.Warning = n, p.AtRule = r, p.Result = t, p.Input = f, p.Rule = d, p.Root = s, p.Node = u, m.registerPostcss(p), wt = p, p.default = p, wt;
}
var St, Uu;
function Gr() {
  if (Uu) return St;
  Uu = 1;
  const r = /* @__PURE__ */ Ir(), E = qr(), { isPlainObject: w } = Cr(), l = Dr(), h = Lr(), { parse: g } = zr(), c = [
    "img",
    "audio",
    "video",
    "picture",
    "svg",
    "object",
    "map",
    "iframe",
    "embed"
  ], f = ["script", "style"];
  function m(b, n) {
    b && Object.keys(b).forEach(function(p) {
      n(b[p], p);
    });
  }
  function i(b, n) {
    return {}.hasOwnProperty.call(b, n);
  }
  function u(b, n) {
    const p = [];
    return m(b, function(y) {
      n(y) && p.push(y);
    }), p;
  }
  function o(b) {
    for (const n in b)
      if (i(b, n))
        return !1;
    return !0;
  }
  function e(b) {
    return b.map(function(n) {
      if (!n.url)
        throw new Error("URL missing");
      return n.url + (n.w ? ` ${n.w}w` : "") + (n.h ? ` ${n.h}h` : "") + (n.d ? ` ${n.d}x` : "");
    }).join(", ");
  }
  St = s;
  const t = /^[^\0\t\n\f\r /<=>]+$/;
  function s(b, n, p) {
    if (b == null)
      return "";
    typeof b == "number" && (b = b.toString());
    let y = "", x = "";
    function a(_, P) {
      const C = this;
      this.tag = _, this.attribs = P || {}, this.tagPosition = y.length, this.text = "", this.openingTagLength = 0, this.mediaChildren = [], this.updateParentNodeText = function() {
        if (j.length) {
          const M = j[j.length - 1];
          M.text += C.text;
        }
      }, this.updateParentNodeMediaChildren = function() {
        j.length && c.includes(this.tag) && j[j.length - 1].mediaChildren.push(this.tag);
      };
    }
    n = Object.assign({}, s.defaults, n), n.parser = Object.assign({}, d, n.parser);
    const v = function(_) {
      return n.allowedTags === !1 || (n.allowedTags || []).indexOf(_) > -1;
    };
    f.forEach(function(_) {
      v(_) && !n.allowVulnerableTags && console.warn(`

âš ï¸ Your \`allowedTags\` option includes, \`${_}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
    });
    const S = n.nonTextTags || [
      "script",
      "style",
      "textarea",
      "option"
    ];
    let A, I;
    n.allowedAttributes && (A = {}, I = {}, m(n.allowedAttributes, function(_, P) {
      A[P] = [];
      const C = [];
      _.forEach(function(M) {
        typeof M == "string" && M.indexOf("*") >= 0 ? C.push(E(M).replace(/\\\*/g, ".*")) : A[P].push(M);
      }), C.length && (I[P] = new RegExp("^(" + C.join("|") + ")$"));
    }));
    const q = {}, T = {}, O = {};
    m(n.allowedClasses, function(_, P) {
      if (A && (i(A, P) || (A[P] = []), A[P].push("class")), q[P] = _, Array.isArray(_)) {
        const C = [];
        q[P] = [], O[P] = [], _.forEach(function(M) {
          typeof M == "string" && M.indexOf("*") >= 0 ? C.push(E(M).replace(/\\\*/g, ".*")) : M instanceof RegExp ? O[P].push(M) : q[P].push(M);
        }), C.length && (T[P] = new RegExp("^(" + C.join("|") + ")$"));
      }
    });
    const D = {};
    let L;
    m(n.transformTags, function(_, P) {
      let C;
      typeof _ == "function" ? C = _ : typeof _ == "string" && (C = s.simpleTransform(_)), P === "*" ? L = C : D[P] = C;
    });
    let N, j, B, F, G, W, ue = !1;
    R();
    const ye = new r.Parser({
      onopentag: function(_, P) {
        if (n.enforceHtmlBoundary && _ === "html" && R(), G) {
          W++;
          return;
        }
        const C = new a(_, P);
        j.push(C);
        let M = !1;
        const $ = !!C.text;
        let X;
        if (i(D, _) && (X = D[_](_, P), C.attribs = P = X.attribs, X.text !== void 0 && (C.innerText = X.text), _ !== X.tagName && (C.name = _ = X.tagName, F[N] = X.tagName)), L && (X = L(_, P), C.attribs = P = X.attribs, _ !== X.tagName && (C.name = _ = X.tagName, F[N] = X.tagName)), (!v(_) || n.disallowedTagsMode === "recursiveEscape" && !o(B) || n.nestingLimit != null && N >= n.nestingLimit) && (M = !0, B[N] = !0, (n.disallowedTagsMode === "discard" || n.disallowedTagsMode === "completelyDiscard") && S.indexOf(_) !== -1 && (G = !0, W = 1)), N++, M) {
          if (n.disallowedTagsMode === "discard" || n.disallowedTagsMode === "completelyDiscard") {
            if (C.innerText && !$) {
              const z = re(C.innerText);
              n.textFilter ? y += n.textFilter(z, _) : y += z, ue = !0;
            }
            return;
          }
          x = y, y = "";
        }
        y += "<" + _, _ === "script" && (n.allowedScriptHostnames || n.allowedScriptDomains) && (C.innerText = ""), (!A || i(A, _) || A["*"]) && m(P, function(z, V) {
          if (!t.test(V)) {
            delete C.attribs[V];
            return;
          }
          if (z === "" && !n.allowedEmptyAttributes.includes(V) && (n.nonBooleanAttributes.includes(V) || n.nonBooleanAttributes.includes("*"))) {
            delete C.attribs[V];
            return;
          }
          let Ue = !1;
          if (!A || i(A, _) && A[_].indexOf(V) !== -1 || A["*"] && A["*"].indexOf(V) !== -1 || i(I, _) && I[_].test(V) || I["*"] && I["*"].test(V))
            Ue = !0;
          else if (A && A[_]) {
            for (const U of A[_])
              if (w(U) && U.name && U.name === V) {
                Ue = !0;
                let H = "";
                if (U.multiple === !0) {
                  const he = z.split(" ");
                  for (const ne of he)
                    U.values.indexOf(ne) !== -1 && (H === "" ? H = ne : H += " " + ne);
                } else U.values.indexOf(z) >= 0 && (H = z);
                z = H;
              }
          }
          if (Ue) {
            if (n.allowedSchemesAppliedToAttributes.indexOf(V) !== -1 && de(_, z)) {
              delete C.attribs[V];
              return;
            }
            if (_ === "script" && V === "src") {
              let U = !0;
              try {
                const H = Se(z);
                if (n.allowedScriptHostnames || n.allowedScriptDomains) {
                  const he = (n.allowedScriptHostnames || []).find(function(J) {
                    return J === H.url.hostname;
                  }), ne = (n.allowedScriptDomains || []).find(function(J) {
                    return H.url.hostname === J || H.url.hostname.endsWith(`.${J}`);
                  });
                  U = he || ne;
                }
              } catch {
                U = !1;
              }
              if (!U) {
                delete C.attribs[V];
                return;
              }
            }
            if (_ === "iframe" && V === "src") {
              let U = !0;
              try {
                const H = Se(z);
                if (H.isRelativeUrl)
                  U = i(n, "allowIframeRelativeUrls") ? n.allowIframeRelativeUrls : !n.allowedIframeHostnames && !n.allowedIframeDomains;
                else if (n.allowedIframeHostnames || n.allowedIframeDomains) {
                  const he = (n.allowedIframeHostnames || []).find(function(J) {
                    return J === H.url.hostname;
                  }), ne = (n.allowedIframeDomains || []).find(function(J) {
                    return H.url.hostname === J || H.url.hostname.endsWith(`.${J}`);
                  });
                  U = he || ne;
                }
              } catch {
                U = !1;
              }
              if (!U) {
                delete C.attribs[V];
                return;
              }
            }
            if (V === "srcset")
              try {
                let U = h(z);
                if (U.forEach(function(H) {
                  de("srcset", H.url) && (H.evil = !0);
                }), U = u(U, function(H) {
                  return !H.evil;
                }), U.length)
                  z = e(u(U, function(H) {
                    return !H.evil;
                  })), C.attribs[V] = z;
                else {
                  delete C.attribs[V];
                  return;
                }
              } catch {
                delete C.attribs[V];
                return;
              }
            if (V === "class") {
              const U = q[_], H = q["*"], he = T[_], ne = O[_], J = O["*"], Yu = T["*"], Ct = [
                he,
                Yu
              ].concat(ne, J).filter(function(Ku) {
                return Ku;
              });
              if (U && H ? z = Ee(z, l(U, H), Ct) : z = Ee(z, U || H, Ct), !z.length) {
                delete C.attribs[V];
                return;
              }
            }
            if (V === "style") {
              if (n.parseStyleAttributes)
                try {
                  const U = g(_ + " {" + z + "}", { map: !1 }), H = ve(U, n.allowedStyles);
                  if (z = je(H), z.length === 0) {
                    delete C.attribs[V];
                    return;
                  }
                } catch {
                  typeof window < "u" && console.warn('Failed to parse "' + _ + " {" + z + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`), delete C.attribs[V];
                  return;
                }
              else if (n.allowedStyles)
                throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
            }
            y += " " + V, z && z.length ? y += '="' + re(z, !0) + '"' : n.allowedEmptyAttributes.includes(V) && (y += '=""');
          } else
            delete C.attribs[V];
        }), n.selfClosing.indexOf(_) !== -1 ? y += " />" : (y += ">", C.innerText && !$ && !n.textFilter && (y += re(C.innerText), ue = !0)), M && (y = x + re(y), x = ""), C.openingTagLength = y.length - C.tagPosition;
      },
      ontext: function(_) {
        if (G)
          return;
        const P = j[j.length - 1];
        let C;
        if (P && (C = P.tag, _ = P.innerText !== void 0 ? P.innerText : _), n.disallowedTagsMode === "completelyDiscard" && !v(C))
          _ = "";
        else if ((n.disallowedTagsMode === "discard" || n.disallowedTagsMode === "completelyDiscard") && (C === "script" || C === "style"))
          y += _;
        else if (!ue) {
          const M = re(_, !1);
          n.textFilter ? y += n.textFilter(M, C) : y += M;
        }
        if (j.length) {
          const M = j[j.length - 1];
          M.text += _;
        }
      },
      onclosetag: function(_, P) {
        if (G)
          if (W--, !W)
            G = !1;
          else
            return;
        const C = j.pop();
        if (!C)
          return;
        if (C.tag !== _) {
          j.push(C);
          return;
        }
        G = n.enforceHtmlBoundary ? _ === "html" : !1, N--;
        const M = B[N];
        if (M) {
          if (delete B[N], n.disallowedTagsMode === "discard" || n.disallowedTagsMode === "completelyDiscard") {
            C.updateParentNodeText();
            return;
          }
          x = y, y = "";
        }
        if (F[N] && (_ = F[N], delete F[N]), n.exclusiveFilter) {
          const $ = n.exclusiveFilter(C);
          if ($ === "excludeTag") {
            M && (y = x, x = ""), y = y.substring(0, C.tagPosition) + y.substring(C.tagPosition + C.openingTagLength);
            return;
          } else if ($) {
            y = y.substring(0, C.tagPosition);
            return;
          }
        }
        if (C.updateParentNodeMediaChildren(), C.updateParentNodeText(), // Already output />
        n.selfClosing.indexOf(_) !== -1 || // Escaped tag, closing tag is implied
        P && !v(_) && ["escape", "recursiveEscape"].indexOf(n.disallowedTagsMode) >= 0) {
          M && (y = x, x = "");
          return;
        }
        y += "</" + _ + ">", M && (y = x + re(y), x = ""), ue = !1;
      }
    }, n.parser);
    return ye.write(b), ye.end(), y;
    function R() {
      y = "", N = 0, j = [], B = {}, F = {}, G = !1, W = 0;
    }
    function re(_, P) {
      return typeof _ != "string" && (_ = _ + ""), n.parser.decodeEntities && (_ = _.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), P && (_ = _.replace(/"/g, "&quot;"))), _ = _.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), P && (_ = _.replace(/"/g, "&quot;")), _;
    }
    function de(_, P) {
      for (P = P.replace(/[\x00-\x20]+/g, ""); ; ) {
        const $ = P.indexOf("<!--");
        if ($ === -1)
          break;
        const X = P.indexOf("-->", $ + 4);
        if (X === -1)
          break;
        P = P.substring(0, $) + P.substring(X + 3);
      }
      const C = P.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
      if (!C)
        return P.match(/^[/\\]{2}/) ? !n.allowProtocolRelative : !1;
      const M = C[1].toLowerCase();
      return i(n.allowedSchemesByTag, _) ? n.allowedSchemesByTag[_].indexOf(M) === -1 : !n.allowedSchemes || n.allowedSchemes.indexOf(M) === -1;
    }
    function Se(_) {
      if (_ = _.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//"), _.startsWith("relative:"))
        throw new Error("relative: exploit attempt");
      let P = "relative://relative-site";
      for (let $ = 0; $ < 100; $++)
        P += `/${$}`;
      const C = new URL(_, P);
      return {
        isRelativeUrl: C && C.hostname === "relative-site" && C.protocol === "relative:",
        url: C
      };
    }
    function ve(_, P) {
      if (!P)
        return _;
      const C = _.nodes[0];
      let M;
      return P[C.selector] && P["*"] ? M = l(
        P[C.selector],
        P["*"]
      ) : M = P[C.selector] || P["*"], M && (_.nodes[0].nodes = C.nodes.reduce(Be(M), [])), _;
    }
    function je(_) {
      return _.nodes[0].nodes.reduce(function(P, C) {
        return P.push(
          `${C.prop}:${C.value}${C.important ? " !important" : ""}`
        ), P;
      }, []).join(";");
    }
    function Be(_) {
      return function(P, C) {
        return i(_, C.prop) && _[C.prop].some(function($) {
          return $.test(C.value);
        }) && P.push(C), P;
      };
    }
    function Ee(_, P, C) {
      return P ? (_ = _.split(/\s+/), _.filter(function(M) {
        return P.indexOf(M) !== -1 || C.some(function($) {
          return $.test(M);
        });
      }).join(" ")) : _;
    }
  }
  const d = {
    decodeEntities: !0
  };
  return s.defaults = {
    allowedTags: [
      // Sections derived from MDN element categories and limited to the more
      // benign categories.
      // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
      // Content sectioning
      "address",
      "article",
      "aside",
      "footer",
      "header",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "hgroup",
      "main",
      "nav",
      "section",
      // Text content
      "blockquote",
      "dd",
      "div",
      "dl",
      "dt",
      "figcaption",
      "figure",
      "hr",
      "li",
      "menu",
      "ol",
      "p",
      "pre",
      "ul",
      // Inline text semantics
      "a",
      "abbr",
      "b",
      "bdi",
      "bdo",
      "br",
      "cite",
      "code",
      "data",
      "dfn",
      "em",
      "i",
      "kbd",
      "mark",
      "q",
      "rb",
      "rp",
      "rt",
      "rtc",
      "ruby",
      "s",
      "samp",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "time",
      "u",
      "var",
      "wbr",
      // Table content
      "caption",
      "col",
      "colgroup",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr"
    ],
    // Tags that cannot be boolean
    nonBooleanAttributes: [
      "abbr",
      "accept",
      "accept-charset",
      "accesskey",
      "action",
      "allow",
      "alt",
      "as",
      "autocapitalize",
      "autocomplete",
      "blocking",
      "charset",
      "cite",
      "class",
      "color",
      "cols",
      "colspan",
      "content",
      "contenteditable",
      "coords",
      "crossorigin",
      "data",
      "datetime",
      "decoding",
      "dir",
      "dirname",
      "download",
      "draggable",
      "enctype",
      "enterkeyhint",
      "fetchpriority",
      "for",
      "form",
      "formaction",
      "formenctype",
      "formmethod",
      "formtarget",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hreflang",
      "http-equiv",
      "id",
      "imagesizes",
      "imagesrcset",
      "inputmode",
      "integrity",
      "is",
      "itemid",
      "itemprop",
      "itemref",
      "itemtype",
      "kind",
      "label",
      "lang",
      "list",
      "loading",
      "low",
      "max",
      "maxlength",
      "media",
      "method",
      "min",
      "minlength",
      "name",
      "nonce",
      "optimum",
      "pattern",
      "ping",
      "placeholder",
      "popover",
      "popovertarget",
      "popovertargetaction",
      "poster",
      "preload",
      "referrerpolicy",
      "rel",
      "rows",
      "rowspan",
      "sandbox",
      "scope",
      "shape",
      "size",
      "sizes",
      "slot",
      "span",
      "spellcheck",
      "src",
      "srcdoc",
      "srclang",
      "srcset",
      "start",
      "step",
      "style",
      "tabindex",
      "target",
      "title",
      "translate",
      "type",
      "usemap",
      "value",
      "width",
      "wrap",
      // Event handlers
      "onauxclick",
      "onafterprint",
      "onbeforematch",
      "onbeforeprint",
      "onbeforeunload",
      "onbeforetoggle",
      "onblur",
      "oncancel",
      "oncanplay",
      "oncanplaythrough",
      "onchange",
      "onclick",
      "onclose",
      "oncontextlost",
      "oncontextmenu",
      "oncontextrestored",
      "oncopy",
      "oncuechange",
      "oncut",
      "ondblclick",
      "ondrag",
      "ondragend",
      "ondragenter",
      "ondragleave",
      "ondragover",
      "ondragstart",
      "ondrop",
      "ondurationchange",
      "onemptied",
      "onended",
      "onerror",
      "onfocus",
      "onformdata",
      "onhashchange",
      "oninput",
      "oninvalid",
      "onkeydown",
      "onkeypress",
      "onkeyup",
      "onlanguagechange",
      "onload",
      "onloadeddata",
      "onloadedmetadata",
      "onloadstart",
      "onmessage",
      "onmessageerror",
      "onmousedown",
      "onmouseenter",
      "onmouseleave",
      "onmousemove",
      "onmouseout",
      "onmouseover",
      "onmouseup",
      "onoffline",
      "ononline",
      "onpagehide",
      "onpageshow",
      "onpaste",
      "onpause",
      "onplay",
      "onplaying",
      "onpopstate",
      "onprogress",
      "onratechange",
      "onreset",
      "onresize",
      "onrejectionhandled",
      "onscroll",
      "onscrollend",
      "onsecuritypolicyviolation",
      "onseeked",
      "onseeking",
      "onselect",
      "onslotchange",
      "onstalled",
      "onstorage",
      "onsubmit",
      "onsuspend",
      "ontimeupdate",
      "ontoggle",
      "onunhandledrejection",
      "onunload",
      "onvolumechange",
      "onwaiting",
      "onwheel"
    ],
    disallowedTagsMode: "discard",
    allowedAttributes: {
      a: ["href", "name", "target"],
      // We don't currently allow img itself by default, but
      // these attributes would make sense if we did.
      img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
    },
    allowedEmptyAttributes: [
      "alt"
    ],
    // Lots of these won't come up by default because we don't allow them
    selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
    // URL schemes we permit
    allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
    allowedSchemesByTag: {},
    allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
    allowProtocolRelative: !0,
    enforceHtmlBoundary: !1,
    parseStyleAttributes: !0
  }, s.simpleTransform = function(b, n, p) {
    return p = p === void 0 ? !0 : p, n = n || {}, function(y, x) {
      let a;
      if (p)
        for (a in n)
          x[a] = n[a];
      else
        x = n;
      return {
        tagName: b,
        attribs: x
      };
    };
  }, St;
}
var Wr = /* @__PURE__ */ Gr();
const $r = /* @__PURE__ */ gr(Wr), Xr = (r) => $r(r, { allowedTags: [], allowedAttributes: {} }), Qr = (r) => (Xr(r).match(/[\w|\d|\s|,|.|\u00C0-\u024F|\u4E00-\u9FA5|\u3041-\u309F]+/giu) ?? []).flatMap((l) => l.match(/[\u4E00-\u9FA5]/gu) ?? l), Jr = (r) => Qr(r).reduce((E, w) => E + (w.trim().length ? w.trim().split(/\s+/u).length : 0), 0), Zr = (r) => r < 1 + Number.EPSILON, Yr = (r, E = "en") => mr[E][r ? "less" : "default"], ei = (r, E = 300, w = "en") => {
  const l = Jr(r), h = Math.round(l / E), g = Zr(h);
  return {
    minutes: h,
    words: l,
    text: `${g ? "" : `${h} `}${Yr(g, w)}`
  };
};
export {
  ei as readingTime,
  Kr as supportedLanguages
};
